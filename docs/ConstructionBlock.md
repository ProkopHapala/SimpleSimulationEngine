# The `ConstructionBlock` System: A Deep Dive

## 1. Introduction & Core Concept

The `ConstructionBlock` system is a powerful tool within the SimpleSimulationEngine for the procedural generation of complex, high-resolution truss structures like bridges, spacecraft hulls, or support towers.

The core idea is to abstract the complex geometry of a truss into a simple, high-level graph. This is analogous to a virtual construction set (like LEGO Technic or ZomeTool) where you first place junction pieces (nodes) and then connect them with struts (edges).

- **Nodes**: The joints or junctions of the truss are represented by `ConstructionBlock` instances.
- **Edges**: The girders, beams, or struts connecting the joints are represented by logical connections in a `BlockBuilder`.

The system then automatically translates this high-level "skeleton" graph into a detailed, low-level geometric mesh suitable for rendering or physics simulation using the `Mesh::Builder2` class.

## 2. System Components

### 2.1. `ConstructionBlock`: The Node

A `ConstructionBlock` represents a single node or joint in the truss.

- **Geometry**: It is fundamentally a cuboid defined by a center position (`pos`) and half-dimensions (`Ls`).
- **Connectivity**: Its connection capabilities are defined by an array of 6 `BlockFace` objects, one for each face of the cube. This is where the system's flexibility originates.

### 2.2. `BlockFace`: The Connection Point

This is the most critical component for defining how girders attach to a block. Instead of being a simple flat square, each face of a `ConstructionBlock` can be configured with different geometries and multiple connection slots.

- **`typ` (Type)**: An integer that determines the shape of the connector geometry on the face. This allows a single block face to become a complex multi-point junction.
  - `typ = 1`: A simple, flat square face generated by `mesh.snapBoxFace`. This provides a single connection point.
  - `typ = 2`: A prism-shaped connector generated by `mesh.snapPrismFace`. This provides two distinct connection faces, useful for creating forks.
  - `typ = 3`: A frustum-shaped connector generated by `mesh.snapFrustrumFace`. This provides five distinct connection faces (front, top, bottom, left, right), allowing for complex 3-way or 5-way junctions.
- **`rot` (Rotation)**: An integer flag (0 or 1) to rotate the face's geometry by 90 degrees, changing the orientation of the connection points.
- **`ids[9]`**: An array that stores the unique logical IDs of the girders that are intended to connect to this face's various slots.
- **`Lhs`**: A `Vec3d` that provides additional geometric parameters to control the shape of the prism and frustum connectors.

### 2.3. `BlockBuilder`: The Skeleton

This class manages the high-level, abstract representation of the entire truss. It holds the "blueprint" of the structure.

- **`blocks`**: A `std::vector<ConstructionBlock>` containing all the nodes in the structure.
- **`edges`**: A `std::vector<Quat4i>` containing all the logical connections (girders) between the blocks.
- **`addBlock(...)`**: Adds a new `ConstructionBlock` node to the skeleton.
- **`connectBlocks(int block_idx1, int block_idx2)`**: This function defines a logical girder between two blocks.
  1.  It calculates the direction vector between the two blocks.
  2.  It automatically selects the best face on each block to attach the girder by calling `block.findFace(direction)`.
  3.  It generates a unique ID for the connection. To distinguish between the two ends of the same girder, the ID for the second block is offset by a large constant (`edge_end_offset`).
  4.  It stores these IDs in the `ids` array of the corresponding `BlockFace` on each block, reserving a connection slot.

## 3. The Generation Process: `ConstructionBlockToMeshBuilder`

This class acts as the "renderer" that translates the abstract `BlockBuilder` skeleton into a tangible `Mesh::Builder2` object.

### 3.1. The `drawBlockBuilder` Workflow

This is the main function that drives the mesh generation. It follows a two-pass process:

**Pass 1: Generate Blocks and Map Connection Points**
1.  The function iterates through every `ConstructionBlock` in the `BlockBuilder` skeleton.
2.  For each block, it calls `drawBlock(block, ..., bStoreFaceIds=true)`.
3.  `drawBlock` first creates the main cuboid body of the block using `mesh.box()`.
4.  Then, `drawBlock` calls `drawFace` for each of the 6 faces.
5.  `drawFace` reads the `face.typ` and calls the appropriate `mesh.snap...Face` function (`snapBoxFace`, `snapPrismFace`, etc.).
6.  These `snap` functions generate the geometry for the connector (e.g., a prism). They create a "chunk" in the `Mesh::Builder2` to represent the connectable face at the end of the connector.
7.  The `if(bStoreFaceIds)` block then calls `replace_chunk`. This function is the key to the system. It retrieves the logical edge ID that was stored in the `BlockFace` and creates an entry in an internal map, `edge2chunk`. This map creates the crucial link: `map[logical_edge_id] = geometric_chunk_id`.

**Pass 2: Generate Girders**
1.  After all blocks and their connection faces have been meshed and mapped, `drawBlockBuilder` iterates through the `BlockBuilder::edges`.
2.  For each logical edge, it uses the `edge2chunk` map to find the two geometric chunk IDs to connect.
3.  It retrieves the vertices of these two chunks using `mesh->getChunkStrip()`.
4.  Finally, it calls `mesh.bridge_quads()` to generate the mesh for the girder, effectively "bridging" the two connection points on the two blocks.

### 3.2. Key `Mesh::Builder2` Concepts for this Workflow

-   **Chunks and `getChunkStrip()`**: A "chunk" is a flexible way to define a group of primitives (like a polygon face). The `chunks` vector stores metadata (like start index and count), while the `strips` vector stores the actual vertex indices that form the primitive. `getChunkStrip(chunk_id)` is the function used to retrieve the vertex indices for a given chunk. This is how the system knows which vertices form the face to be connected by a girder.

-   **`replace_chunk()`**: This function is the lynchpin between the logical skeleton and the geometric mesh. Its primary role is to populate the `edge2chunk` map. When a connectable face (like the end of a prism) is created as a chunk, `replace_chunk` is called. It takes the logical edge ID that was supposed to connect there and maps it to the ID of the newly created geometric chunk.

-   **`extrudeFace()`**: This is a mesh editing operation that highlights the power of the chunk system. It works very similarly to how girders are built:
    1.  It takes the ID of a face chunk.
    2.  It creates a new, parallel face by shifting the original vertices along the face normal.
    3.  It then calls `bridge_quads` to connect the original face chunk to the new face chunk, creating the side walls of the extrusion.

## 4. Practical Example: Building a Truss Structure

To generate a complex truss like a bridge or a crane section:

1.  **Define the High-Level Structure**:
    -   Create a `BlockBuilder` instance.
    -   Use `addBlock()` to place the main joints/nodes of your structure in 3D space. You can specify their size (`Ls`) and the type of connectors on their faces by pre-configuring the `BlockFace` array for each block before adding it.
    -   Use `connectBlocks(i, j)` to define the girders (edges) between the joints. This populates the `ids` arrays in the `BlockFace`s.

2.  **Generate the Mesh**:
    -   Create a `Mesh::Builder2` instance to hold the final geometry.
    -   Create a `ConstructionBlockToMeshBuilder` instance and link it to your mesh (`cbm.mesh = &mesh`).
    -   Call `cbm.drawBlockBuilder(skelet)`.

The result is a detailed mesh in the `mesh` object, ready for simulation or rendering, generated from a simple, high-level description of nodes and edges. The complexity of the joints and connections is handled automatically based on the `BlockFace` types.

## 5. Keyboard Controls in `constructionBlockApp`

The demo application provides interactive editing capabilities for the generated mesh.

-   **`F` key**: When a loop of edges is selected, pressing `F` calls `mesh.selectionToFace()`, which creates a new polygon face from the selected edge loop.
-   **`E` key**: When a face is selected (in face selection mode), pressing `E` calls `mesh.extrudeFace(ipick, 5.0)`. This extrudes the selected face outwards by 5.0 units, creating a new 3D volume.
-   **`I`, `O`, `P` keys**: These keys switch between selection modes:
    -   `I`: Edge selection mode.
    -   `O`: Vertex selection mode.
    -   `P`: Face selection mode.

## 6. Relevant Files and Class Structures

This section provides a high-level overview of the key files and the classes they contain, which are essential for understanding the `ConstructionBlock` system.

### `ConstructionBlock.h`

This is the core header file defining the high-level components for building truss skeletons.

-   **class `BlockFace`**: Represents a single connectable face on a `ConstructionBlock`.
    -   **Properties**: `typ`, `rot`, `nid`, `ids`, `Lhs`
    -   **Methods**: `clean`, `addId`, `removeIdAt`, `findId`, `removeId`

-   **class `ConstructionBlock`**: Represents a single node or joint in the truss.
    -   **Properties**: `pos`, `Ls`, `faces`
    -   **Methods**: `cleanFaces`, `findId`, `findFace`, `addId`, `replaceId`, `removeIdAt`, `removeId`

-   **class `BlockBuilder`**: Manages the collection of blocks and their connections (the "skeleton").
    -   **Properties**: `edge_end_offset`, `blocks`, `edges`
    -   **Methods**: `addBlock`, `connectBlocks`

-   **namespace `Mesh`**
    -   **class `ConstructionBlockToMeshBuilder`**: The "renderer" that converts the `BlockBuilder` skeleton into a `Mesh::Builder2` mesh.
        -   **Properties**: `mesh`, `edge2chunk`, `stickTypes`, `stickMaks`
        -   **Methods**: `printEdge2chunk`, `replace_chunk`, `drawFace`, `drawBlock`, `drawBlockBuilder`

### `MeshBuilder2.h`

This header defines the low-level mesh construction and manipulation toolkit.

-   **namespace `Mesh`**
    -   **struct `VertT`**: A template for a vertex, containing position, normal, and UV data.
    -   **class `Builder2`**: The main mesh building class.
        -   **Data Properties**: `blocks`, `verts`, `edges`, `tris`, `chunks`, `strips`, `vert2edge`, `selection`, `selset`
        -   **Configuration Properties**: `max_size`, `face_type`, `edge_type`, `use_vert2edge`, `bPolygonToTris`, `bAdditiveSelect`, `selection_mode`
        -   **Primitive Creation**: `block`, `vert`, `edge`, `tri`, `stick`, `stickTo`, `chunk`, `quad`
        -   **Strip/Loop Creation**: `edgst`, `trist`, `vstrip`, `fstrip`, `rope`, `ring`, `tube`, `ngon`
        -   **Complex Shape Generation**: `box`, `plate`, `panel`, `girder1`, `wheel`
        -   **Face Connector Generation**: `snapBoxFace`, `frustrumFace`, `snapFrustrumFace`, `prismFace`, `snapPrismFace`
        -   **Mesh Editing**: `extrudeFace`, `extrudeVertLoop`, `bridge_quads`, `plateBetweenEdges`, `selectionToFace`
        -   **Selection & Picking**: `pickVertex`, `pickEdge`, `pickTriangle`, `pickSelect`, `selectRect`, `clearSelection`
        -   **Topological Utilities**: `sortEdgeLoop`, `findEdgeByVerts`, `buildVerts2Edge`
        -   **Information & Debugging**: `printSizes`, `printVerts`, `printEdges`, `printSelection`

### `constructionBlockApp.cpp`

This is the main application file that demonstrates the usage of the `ConstructionBlock` system.

-   **class `ConstructionBlockApp`**: The main application class inheriting from `AppSDL2OGL_3D`.
    -   **Global Objects**: `mesh` (Mesh::Builder2), `block` (ConstructionBlock), `skelet` (BlockBuilder)
    -   **Properties**: `bViewBlockBuilder`, `bViewMesh`, `gui`, `viewControls`, `contextMenu`, `ipick`
    -   **Core Methods**: `draw`, `drawHUD`, `eventHandling`, `keyStateHandling`
    -   **Constructor `ConstructionBlockApp(...)`**: Contains the primary logic for setting up the test scene, including creating the `BlockBuilder` skeleton and calling `cbm.drawBlockBuilder` to generate the mesh.