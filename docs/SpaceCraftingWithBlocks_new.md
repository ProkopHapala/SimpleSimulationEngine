## Concrete Problem: A Robust Implementation of Block-Based Construction

This document outlines the implementation of the block-based construction paradigm within the `SpaceCraft` system. The central goal was to generate rigid, stable spacecraft structures by replacing the previous line-based girder generation with a more robust block-and-bridge approach, while maximizing the reuse of existing components and logic.

### 1. The Core of the New System: `BuildCraft_blocks`

The block-based construction paradigm has been implemented, replacing the previous `BuildCraft_truss` logic for rigid structures. The new core function is `BuildCraft_blocks` (located in `cpp/common/Orbital/SpaceCraft2Mesh2.h`). It translates the high-level, abstract `SpaceCraft` definition into a concrete, low-level `Mesh::Builder2` representation, drawing inspiration from the logic in `constructionBlockApp.cpp`.

**Key Principles of the Implementation:**
*   **Decoupling:** The `SpaceCraft` object continues to define the ship's logical structure (which nodes connect to which). `BuildCraft_blocks` is solely responsible for the geometric interpretation of that structure.
*   **Component Interpretation:** The meaning of `SpaceCraft` components has been adapted for the new paradigm:
    *   A `Node` in the `SpaceCraft` object now represents a structural block (e.g., an octahedron).
    *   A `Girder` represents the truss-like bridge connecting two blocks.
*   **Property Assignment:** A critical aspect of the implementation is that during mesh generation, the `pointRange`, `stickRange`, and `chunkRange` properties of each `Node` and `Girder` object are correctly populated. This maintains the vital link between the high-level component and its low-level mesh data, which is essential for all subsequent operations (e.g., pathfinding, picking, physics).

### 2. The `BuildCraft_blocks` Workflow

The function is structured in two main passes, one for nodes (blocks) and one for girders (bridges), executed by dedicated helper functions.

**Pass 1: Generating Node Blocks via `nodeBlock_to_mesh`**

The function first iterates through `craft.nodes`. For each `Node* o`:
1.  **Record State:** The starting sizes of `mesh.verts`, `mesh.edges`, and `mesh.chunks` are recorded.
2.  **Generate Mesh:** The `nodeBlock_to_mesh` helper is called. It creates the block's geometry at the node's position (`o->pos`) by calling `mesh.addCMesh(Solids::Octahedron, ...)` to generate the wireframe and faces. The faces are stored as "chunks" which serve as connection points for girders.
3.  **Store Ranges:** After generation, the new mesh sizes are used to populate the `pointRange`, `stickRange`, and `chunkRange` properties in the `Node` object.

> **Architectural Implementation:** To allow `Node`s to properly own their mesh geometry, the `Node` class was modified to inherit from `ShipComponent` instead of `Object`. This provides it with the necessary `pointRange`, `stickRange`, and `chunkRange` properties.

**Pass 2: Generating Girder Bridges via `girderBlocks_to_mesh`**

After all node blocks are created, the function iterates through `craft.girders`. For each `Girder* o`:
1.  **Identify Connection Faces:** The `girderBlocks_to_mesh` helper is called. It identifies the two `Node`s the girder connects (`o->nodes.x` and `o->nodes.y`).
2.  **Record State:** The starting sizes of `mesh.verts` and `mesh.edges` are recorded.
3.  **Generate Mesh:** The function calls `mesh.bridgeFacingPolygons`. This powerful helper function automatically finds the face (chunk) on each block that points most directly towards the other block (using `mesh.findMostFacingNormal`). It then calls `mesh.bridge_quads` to generate the truss structure between these two faces.
4.  **Store Ranges:** The resulting vertex and edge ranges are stored in the `Girder`'s `pointRange` and `stickRange` properties.

### 3. Attaching Complex Components: The Wheel Example

With a robust `BuildCraft_blocks` function in place for the main hull, the next challenge is attaching other complex components like wheels (`Ring`s). The logic remains asymmetric, consistent with the previous system: sliders are **fixed** to the girders and **slide** along the wheel's path. This section outlines the concrete steps to achieve this.

#### Step 3.1: Path Extraction from the Ring (No Changes Needed)

The `Ring` component's mesh is still generated by `ring_to_mesh`, which calls `mesh.wheel()`. This creates a regular, segmented structure. The `Slider`'s movement path is extracted using the `Ring::sideToPath` method.

-   `mesh.wheel()` creates a wheel from 4-vertex segments.
-   `Ring::sideToPath(side, ...)` correctly interprets this structure, extracting one of the four longitudinal vertex paths along the wheel's circumference.

**Conclusion:** The existing logic for defining a slider's path on a `Ring` is compatible with the new system and requires no changes.

#### Step 3.2: The New Wheel Attachment Workflow

The core of the attachment process involves finding where to anchor the sliders on the hull girders.

1.  **Create the `Ring` Component:** A `Ring` is created in the `SpaceCraft` object. During the `BuildCraft_truss` (or a similar build function) call, its mesh is generated using `mesh.wheel()`. Its `pointRange` and `stickRange` are stored. The `Ring`'s `sideToPath` method is now ready to provide the circular path for the sliders.

2.  **Find Attachment Points on Girders:** For each of the 3-4 sliders that will connect the wheel to the hull:
    a.  Identify the target `Girder` on the hull.
    b.  Use the `intersect_RingGirder` function. This function takes the `Ring` and the target `Girder` and analytically calculates the 3D intersection point `p_intersect` on the girder's primary axis.

3.  **Materialize Sliders and their anchor Points:** This step happens during the mesh generation phase (e.g., in a `sliders_to_mesh` helper function). For each pre-defined `Slider* o` and its calculated intersection point `p_intersect`:
    a.  **Record State:** Get the current size of `mesh.verts` and `mesh.edges` before generating the anchor point geometry.
    b.  **Generate anchor Point Mesh:** Call `mesh.make_anchor_point(p_intersect, ...)`. This creates a robust physical attachment point on the girder's truss by adding a new vertex and connecting it to nearby existing vertices of the girder with new sticks.
    c.  **Configure the Slider Component:**
        i.  The `make_anchor_point` function returns the index of the new primary vertex (`ivert`). This vertex represents the slider's fixed attachment point. Set `o->ivert = ivert`.
        ii. The new geometry (vertices and edges) created by `make_anchor_point` is now "owned" by the `Slider` component. Store the resulting vertex and edge ranges in the `Slider`'s `pointRange` and `stickRange` properties.
    d.  **Configure Sliding Path:** Initialize the slider's path of movement by calling `sideToPath` on the **`Ring`** component. This populates `o->path.ps` with the vertex indices of the wheel's circumference, allowing it to slide.

This revised workflow is clear, uses existing components, and correctly assigns ownership of all mesh geometry.

#### Step 3.3: Owning anchor Geometry with the `Slider` Component

A key principle of the construction system is that all generated mesh geometry (vertices and edges) must be "owned" by a high-level `ShipComponent` via its `pointRange` and `stickRange` properties. This ensures a complete mapping between the logical design and the physical simulation data.

The `Slider` component is the ideal owner for the anchor point geometry created by `make_anchor_point`.

*   **Inheritance:** The `Slider` class inherits from `Node`, which in the new paradigm inherits from `ShipComponent`. This means `Slider` already has the necessary `pointRange` and `stickRange` members.
*   **Functionality:** A slider has two distinct functions: a fixed anchor point and a movable path. It is logical for the `Slider` component to manage the data for both.
*   **Implementation:** As described in the workflow above, when `make_anchor_point` is called for a specific slider, the generated vertex and edge ranges are stored directly in that slider's `pointRange` and `stickRange`.

This approach cleanly maps all generated geometry to high-level components, fulfilling a core requirement of the new system without introducing any new classes or unnecessary complexity.