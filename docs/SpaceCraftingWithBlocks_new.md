## Concrete Problem: A Robust Plan for Block-Based Construction

This document outlines a concrete plan for integrating the new block-based construction paradigm into the existing `SpaceCraft` system. The central goal is to re-implement the `BuildCraft_truss` function to generate rigid, stable spacecraft structures while maximizing the reuse of existing components and logic.

### 1. The Core Task: Re-implementing `BuildCraft_truss`

The primary objective is to replace the current implementation of `BuildCraft_truss` (in `cpp/common/Orbital/SpaceCraft2Mesh2.h`) with one that understands and generates block-based structures. The current function iterates through `craft.girders`, `craft.ropes`, etc., and calls specific `Mesh::Builder2` functions like `mesh.girder1()` for each. The new implementation will follow the same high-level pattern but use different mesh generation techniques.

**Design Goal:** The re-implementation must translate the high-level, abstract `SpaceCraft` definition into a concrete, low-level `Mesh::Builder2` representation, inspired by the logic in `constructionBlockApp.cpp`.

**Key Principles:**
*   **Decoupling:** The `SpaceCraft` object will continue to define the ship's logical structure (which nodes connect to which). `BuildCraft_truss` will be solely responsible for the geometric interpretation of that structure.
*   **Iteration:** The new `BuildCraft_truss` will still iterate through `craft.nodes` and `craft.girders`. However, the interpretation of these components changes:
    *   A `Node` in the `SpaceCraft` object now represents a structural block (e.g., an octahedron).
    *   A `Girder` represents the truss-like bridge connecting two blocks.
*   **Mesh Generation:** Inside the loops, the function will use `Mesh::Builder2` methods like `facingNodes` and `bridgeFacingPolygons` to generate the mesh for blocks and girders.
*   **Property Assignment:** It is **absolutely critical** that during mesh generation, the `pointRange` and `stickRange` properties of each `Node` and `Girder` object are correctly populated. This maintains the vital link between the high-level component and its low-level mesh data, which is essential for all subsequent operations (e.g., pathfinding, picking, physics).

### 2. Proposed `BuildCraft_truss` Workflow

The new function will be structured in two main passes: one for nodes (blocks) and one for girders (bridges).

**Pass 1: Generating Node Blocks**

The function will first iterate through `craft.nodes`. For each `Node* o` in the vector:
1.  **Record State:** Get the current size of `mesh.verts`, `mesh.edges`, and `mesh.chunks` before generating the block.
2.  **Generate Mesh:** Call the appropriate `Mesh::Builder2` functions to create the block's geometry at the node's position (`o->pos`). This will likely involve a call to `mesh.addCMesh(Solids::Octahedron, ...)` followed by `mesh.addFaces(...)` to create the connection points (chunks) for the girders.
3.  **Store Ranges:** After generation, get the new mesh sizes and store the generated geometry ranges in the `Node` object.

> **Architectural Consideration:** The current `Node` class inherits from `Object` and lacks `pointRange` and `stickRange`. To solve this, the `Node` class should be modified to inherit from `ShipComponent`. This is a clean solution that does not introduce inheritance problems and allows `Node`s to properly own their mesh geometry.

**Pass 2: Generating Girder Bridges**

After all node blocks are created, the function will iterate through `craft.girders`. For each `Girder* o`:
1.  **Identify Connection Faces:** The `Girder` connects two `Node`s (`o->nodes.x` and `o->nodes.y`). The function must determine which face (chunk) on each block to connect. This can be done using `mesh.findMostFacingNormal`, which finds the face on each block that points most directly towards the other block. This requires that the face chunks for each block have been created and are accessible.
2.  **Record State:** Get the current size of `mesh.verts` and `mesh.edges`.
3.  **Generate Mesh:** Call `mesh.bridge_quads` (or the higher-level `bridgeFacingPolygons`) using the two face chunks identified in the previous step.
4.  **Store Ranges:** Store the resulting vertex and edge ranges in the `Girder`'s `pointRange` and `stickRange` properties.

### 3. Attaching a Wheel: A Concrete Application

With a robust `BuildCraft_truss` in place, we can address the task of attaching a `Ring` to the new hull. The logic is asymmetric: sliders are **fixed** to the girders and **slide** along the wheel's path.

**Step 3.1: Adapting `Girder` for Path Extraction**

We do not need to redefine the `Girder` class. We only need to provide a concrete implementation for its existing virtual method, `sideToPath`, that can work with the new mesh topology. A girder generated by `bridge_quads` has four main longitudinal "corner" struts, which are the natural paths for intersection tests.

**Proposed `Girder::sideToPath` Implementation:**

```cpp
// In the Girder class, derived from StructuralComponent

virtual int sideToPath(int side, int*& inds, bool bAlloc=true, int nmax=-1) const override {
    // 'side' would be an index from 0 to 3, for the four corner paths.
    // This method needs to traverse the girder's mesh (using its pointRange
    // and stickRange) to find the ordered sequence of vertex indices
    // that form the specified corner path.
    // This is a graph traversal problem on a subset of the mesh defined by the ranges.
    // The implementation will be complex but is essential.
    // It would start at one ofthe four vertices of the starting quad face
    // and walk along the longitudinal edges to the corresponding end face.
    // ...
    // return number of vertices in the path
}
```

**Step 3.2: The New Wheel Attachment Workflow**

1.  **Create the `Ring` Component:** A `Ring` is created, and its mesh is generated using `mesh.wheel()`. Its `pointRange` and `stickRange` are stored. The `Ring`'s `sideToPath` method provides the circular path for the sliders.
2.  **Find Attachment Points on Girders:** For each slider:
    a.  Identify the target `Girder` on the hull.
    b.  Use the girder's new `sideToPath()` implementation to get one of its main longitudinal struts as a polyline (a sequence of vertices).
    c.  Approximate this strut as a single line segment from its start to end point.
    d.  Use the existing `intersect_RingGirder` function. It takes the `Ring` and the `Girder` (from which the line segment is derived) and calculates the precise 3D intersection point. This point lies on the girder.
3.  **Create Stable Anchors on Girders:**
    a.  At each precise intersection location, call `mesh.make_anchor_point(pos, ...)`.
    b.  This function creates a robust physical attachment point on the girder's truss by adding a new vertex and connecting it to nearby existing vertices of the girder with new sticks. It returns the index of the new primary vertex (`ivert`). This is the fixed point for the slider.
4.  **Create and Configure Sliders:**
    a.  Create a `Slider` component for each anchor point.
    b.  The slider's position is now fixed. Set its `ivert` to the vertex index returned by `make_anchor_point`.
    c.  Initialize the slider's path of movement by calling `sideToPath` on the **`Ring`** component.

**Step 3.3: Tracking Anchor Geometry with an `Anchor` Component**

A key challenge is that `mesh.make_anchor_point` creates new geometry (vertices and edges) that is not owned by any high-level component. This breaks our mapping principle.

**Proposed Solution:** Introduce a new `Anchor` component.

*   **Class Definition:** `class Anchor : public StructuralComponent`
*   **Workflow:**
    1.  When `mesh.make_anchor_point()` is called, it not only creates the mesh geometry but also instantiates a corresponding `Anchor` object and adds it to a new `craft.anchors` vector.
    2.  This `Anchor` object stores the `pointRange` and `stickRange` of the supporting sticks created by the function.
    3.  It also stores the index of its primary vertex (`ivert`), which is the actual attachment point.
    4.  A `Slider`'s `ivert` is then set to this primary vertex. The `Anchor` component itself simply serves to own the associated mesh geometry.

This approach cleanly maps all generated geometry to high-level components, fulfilling a core requirement of the new system without needing to alter the `Node` or `Slider` classes in complex ways.