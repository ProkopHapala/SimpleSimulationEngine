# SpaceCraft Building System – High‑Level Overview (WIP)

This document summarizes the current spacecraft building pipeline and where to find the relevant functionality in the codebase. It focuses on **building spacecraft geometry from Lua** and exporting it via `Mesh::Builder2` for later simulation (truss dynamics, radiosity, scattering).

---

## 1. Big Picture: From Lua Script to Simulation

Conceptually, the system is layered:

1. **Design (Lua + `SpaceCraft`)**  
   Lua scripts describe spacecraft structure and components.  
   C++ side: `EditSpaceCraft.h`, `SpaceCraft.h`, `SpaceCraftComponents.h`.

2. **Geometric Conversion (`SpaceCraft2Mesh*` → `Mesh::Builder2`)**  
   High‑level components are turned into a concrete 3D truss/block mesh.  
   C++ side: `SpaceCraft2Mesh2.h` (older truss‑style), `SpaceCraft2Mesh_blocks.h` / `BuildCraft_blocks` (new block‑based system), using `MeshBuilder2.h`.

3. **Derived Simulation Representations**  
   - **Truss dynamics**: `TrussDynamics_d` / `_f` built from mesh edges and materials.  
   - **Radiation / radiosity / scattering**: surfaces from the mesh are fed into `TriangleRayTracer`, `Radiosity`, and scattering solvers.  
   - **Damage and hit‑testing**: fast projectile clouds are treated as line segments between positions at \(t\) and \(t+\Delta t\), intersected with sticks and triangles from the mesh using the same infrastructure as raytracing (`TriangleRayTracer`). Nuclear and radiative damage reuse the radiosity / scattering tools with different source terms (engines, stars, weapons, distant lasers as described in `encyclopedia/space_warfare/07_Physical_model_and_equations.md`).

The **main flow we care about now** is:

> **Lua script** → `EditSpaceCraft` C API → `SpaceCraft` object → `BuildCraft_blocks` → `Mesh::Builder2` mesh → OBJ / truss / other exports.

This flow is exercised headless by `spaceCraftMeshExport` and interactively by the editor/dynamics apps.

---

## 2. Core Data Model: `SpaceCraft` and Components

**Location:**

- `cpp/common/Orbital/SpaceCraft.h`
- `cpp/common/Orbital/SpaceCraftComponents.h`

### 2.1 `SpaceCraft` container

`SpaceCraft` (namespace `SpaceCrafting`) is the **central logical model** of a ship:

- Owns vectors of pointers to all component types:
  - Structural: `nodes`, `girders`, `ropes`, `rings`, `sliders`, `welds`.
  - Plates: `radiators`, `shields`, `collectors`.
  - Volumetric modules: `tanks`, `balloons`, `rocks`, `thrusters`, `pipes`.
  - Other: `guns`, generic `components` / `build_order` to track construction order.
- Holds a `SpaceCraftWorkshop* workshop` for materials and catalogs.
- Maintains `nodeMeshes` / `defaultNodeMesh` for rendering and for block‑based generation.
- Provides helpers used across the system:
  - Structural access: `getStructuralComponent(id, type)`.
  - Lifecycle: `clear()`, `checkIntegrity()`, `updatePanelMaterials()`.
  - Picking & queries: `pick(...)`, `getPicked(...)`, `getVertAlong(...)`, raycasting helpers (`rayPlate`, `rayLinkLine`).

`build_order` and `components` are especially important for mesh building: components may depend on geometry generated by earlier ones (e.g. bound nodes, sliders).

### 2.2 Component hierarchy (`SpaceCraftComponents.h`)

The header defines a **typed hierarchy** of ship parts, all ultimately derived from `CatalogItem` and mostly from `ShipComponent`:

- **`CatalogItem`**: base with `id`, `kind`, `name`.
- **`Material`, `StickMaterial`, `PanelMaterial`, `FuelType`, `Commodity`**: catalogs owned by `SpaceCraftWorkshop`.
- **`ShipComponent`**: base for all physical components. Key fields:
  - `shape`, `face_mat`, `mass`.
  - `pointRange`, `stickRange`, `chunkRange`: ranges into `Mesh::Builder2` vectors linking a component to its mesh geometry.
- **`StructuralComponent`**: line‑like or frame elements:
  - Holds `nodes` (attachment `Node*`s), `mvert`, and helpers like `update_nodes`, `updateSlidersPaths`, `findNearestPoint`, `toBuckets`.
- **Specific components** (selection):
  - **`Node`**: now a `ShipComponent` (for block‑based system). Stores position, binding (`boundTo`, `calong`, `along`), and mesh vertex index `ivert`. Method `updateBound()` resolves bound nodes to mesh vertices.
  - **`Girder`, `Rope`**: `NodeLinker`s that connect two or more `Node`s.
  - **`Ring`**: wheel‑like truss; provides `sideToPath` used by sliders.
  - **`Plate`** and derived `Radiator`, `Shield`, `Collector`.
  - **`Modul`** and derived `Tank`, `Thruster`, `Balloon`, `Rock`.
  - **`Weld`**: joins structural components (uses `pointRange`/`stickRange` to create constraints in mesh space).
  - **`Slider`**: inherits from `Node`, owns a `Path` (`ps`, `cur`, `closed`) and parameters for motion along a mesh path.

All higher‑level behavior (Lua wrappers, mesh builders, dynamics glue) assumes these components correctly populate their `id`, `kind`, and *mesh range* fields.

### 2.3 `SpaceCraftWorkshop`

The workshop collects **materials and component archetypes**:

- Catalogs for `Material`, `StickMaterial`, panel materials, thruster/gun types, etc.
- Used when building the mesh and especially when exporting to truss:
  - `StickMaterial` → spring constants (`Kpull`, `Kpush`), mass per length, pre‑strain, damping.

Workshop instances live globally in `EditSpaceCraft.h` (`SpaceCrafting::workshop`) and are pointed to by each `SpaceCraft`.

---

## 3. Lua Interface: `EditSpaceCraft.h`

**Location:** `cpp/common/Orbital/EditSpaceCraft.h`

This header implements the **Lua → C++ bridge** for constructing spacecraft:

- Global state in namespace `SpaceCrafting`:
  - `lua_State* theLua`.
  - `SpaceCraft* theSpaceCraft`.
  - `SpaceCraftWorkshop workshop`.
  - `Radiosity radiositySolver` (for future/light transport tools).
- `initSpaceCraftingLua()`:
  - Creates `theLua`, opens std Lua libs.
  - Sets `theSpaceCraft->workshop = &workshop`.
  - Registers C functions exposed to Lua:
    - Materials: `Material`, `StickMaterial`.
    - Structure: `Node`, `BoundNode`, `Rope`, `Rope2`, `Girder`, `Ring`, `Ring2`, `Slider`, `Weld`.
    - Plates / volumes / systems: `Radiator`, `Shield`, `Tank`, `Thruster`, `Gun`, `Balloon`, `Rock`.
- Each `l_*` function:
  - Reads Lua arguments (positions, connectivity, parameters, material names).
  - Allocates the appropriate component (`new Node`, `new Girder`, etc.).
  - Fills fields, pushes the object into the corresponding `SpaceCraft` vector.
  - Returns the new component’s `id` back to Lua.

Typical Lua ship script workflow:

1. Define base materials and stick materials.  
2. Create `Node`s in space or `BoundNode`s attached along existing structures.  
3. Connect nodes via `Girder`, `Rope`, `Ring`, etc.  
4. Add plates (`Radiator`, `Shield`) and modules (`Tank`, `Thruster`, `Gun`, `Balloon`, `Rock`).

`EditSpaceCraft` is reused both by the GUI editors and by headless tools like `spaceCraftMeshExport`.

---

## 4. Mesh Building: `BuildCraft_blocks` and `Mesh::Builder2`

### 4.1 `Mesh::Builder2` as common mesh backbone

**Location:** `cpp/common/geometry/MeshBuilder2.h` and `docs/MeshBuilder2.md`

`Mesh::Builder2` is the **unified mesh toolkit** used across the engine:

- Stores:
  - `verts`, `edges`, `tris` – fundamental geometry.
  - `chunks`, `strips` – higher‑level faces/strips and other variable‑length primitives.
- Provides high‑level generators used heavily by spacecraft code:
  - Truss/structural: `girder1`, `rope`, `wheel`, `plateOnGriders`, `panel`, `make_anchor_point`, `bridge_quads`, `bridgeFacingPolygons`.
  - Block connectors used by the construction‑block system: `snapBoxFace`, `snapPrismFace`, `snapFrustrumFace`.
- Exports:
  - `write_obj(const char* fname, uint8_t mask)` for Wavefront OBJ.
  - Debug helpers: `printSizes()`, `checkAllPointsConnected()`, selection and picking helpers.

The **spacecraft pipeline treats `Builder2` as the authoritative geometric representation** from which we can:

- Render (via OpenGL wrappers).
- Build truss simulations (`TrussDynamics_d` / `_f`).
- Build radiosity and scattering meshes.

### 4.2 Truss‑style mesh (`BuildCraft_truss`) – legacy but still relevant

**Location:** documented in `docs/SpaceCrafting.md`, implemented in `SpaceCraft2Mesh2.h`.

Original pipeline:

1. Iterate `craft.nodes` to assign `ivert` and generate isolated vertices.
2. For each `Girder`, `Rope`, `Ring`:
   - Call `update_nodes()` to ensure attached nodes know their mesh vertices.
   - Use `mesh.girder1`, `mesh.rope`, or `mesh.wheel` to generate detailed trusses.
   - Fill `pointRange` / `stickRange`.
3. Plates and welds add surfaces and additional bonds between component ranges.

This is still important for understanding how **bound nodes** and **sliders** relate to mesh vertices and for the dynamics code (`sliders2edgeverts`, `applySliders2sim`).

### 4.3 Block‑based mesh (`BuildCraft_blocks`) – current primary path

**Location:**

- Code: `cpp/common/Orbital/SpaceCraft2Mesh2.h` (or `SpaceCraft2Mesh_blocks.h` depending on exact include), see docs in `docs/SpaceCraftingWithBlocks_new.md`.

Key ideas (block‑based construction):

- `Node` ≈ structural **block** (e.g. octahedral or cubic CMesh).  
- `Girder` ≈ **bridge** connecting faces of two blocks.
- `BuildCraft_blocks` performs two main passes:

  1. **Node blocks** via `nodeBlock_to_mesh`:
     - For each `Node* o`:
       - Record current mesh sizes.
       - Call `mesh.addCMesh(Solids::Octahedron, ...)` (or other CMesh) centered at `o->pos`.
       - Store the generated ranges into `o->pointRange`, `o->stickRange`, `o->chunkRange`.
     - This relies on `Node` inheriting from `ShipComponent` (so it owns mesh ranges).

  2. **Girder bridges** via `girderBlocks_to_mesh`:
     - For each `Girder* o` connecting nodes A/B:
       - Use the node blocks’ `chunkRange` to find candidate faces.
       - Call `mesh.bridgeFacingPolygons` to automatically choose and connect the most facing faces, generating a truss‑like bridge.
       - Store resulting ranges in the `Girder`’s `pointRange` and `stickRange`.

- Additional components (e.g. wheels/rings) reuse existing truss logic:
  - `Ring` geometry is generated by `ring_to_mesh` → `mesh.wheel()`.
  - `Ring::sideToPath` can extract vertex loops used by `Slider` paths (no change needed for blocks).

### 4.4 Sliders and wheel attachments in the block system

**Goal:** robustly attach wheels to the block‑based hull using sliders.

Workflow (see `SpaceCraftingWithBlocks_new.md`):

1. **Build wheel (`Ring`)** using existing truss tools. Store its `pointRange` and `stickRange`.
2. **Find girder–ring intersection** using `intersect_RingGirder` to get attachment points on hull girders.
3. **Create slider anchor geometry**:
   - For each slider, around the intersection point:
     - Use `mesh.make_anchor_point` to create an anchored vertex and reinforcement sticks.
     - Store anchor ranges in the `Slider`’s `pointRange` / `stickRange`.
     - Set `Slider::ivert` to the anchor vertex.
4. **Initialize sliding path**:
   - Use `Ring::sideToPath` to populate `Slider::path.ps` with a vertex loop around the wheel.

This preserves the core invariant: **every piece of geometry belongs to some `ShipComponent`** via its ranges, and sliders carry both their anchor and their kinematic path.

---

## 5. Headless Mesh Export: `spaceCraftMeshExport`

**Location:**

- Code: `cpp/apps/OrbitalWar/spaceCraftMeshExport.cpp`
- Docs: `docs/spaceCraft_mesh_export_cli.md`

Purpose: **run the Lua → SpaceCraft → BuildCraft_blocks → OBJ (+ optional truss) pipeline without any SDL/OpenGL or interactive editor.**

Main steps:

1. **Global initialization**
   - `theSpaceCraft = new SpaceCraft();`
   - `initSpaceCraftingLua();` (sets up Lua, registers builders, hooks workshop).

2. **Parse CLI (`LambdaDict`, `process_args`)**
   - `-s <lua>` – required ship script.
   - `-o <obj>` – output OBJ path (default `ship.obj`).
   - `-t <truss>` – optional text truss file.
   - `-v <int>` – global `verbosity` (from `globals.h`).

3. **Load Lua ship & build `SpaceCraft`**
   - `theSpaceCraft->clear();`
   - `Lua::dofile(theLua, shipPath);` – invokes Lua builders (`Node`, `Girder`, etc.).
   - `theSpaceCraft->checkIntegrity();`.

4. **Build mesh**
   - `Builder2 mesh;` → `mesh.clear();`
   - `BuildCraft_blocks(mesh, *theSpaceCraft, 30.0);`
   - Optional diagnostics: `mesh.printSizes(); checkSpaceCraftMesh(mesh, *theSpaceCraft, ...)`.

5. **Write OBJ and optional truss**
   - `mesh.write_obj(objPath);`
   - If `-t` given: `exportSimToFile(trussPath, mesh, workshop);`  
     (keeps truss I/O decoupled from `TrussDynamics_d`, as described in `spaceCraft_mesh_export_cli.md`).

This CLI is ideal for regression tests on the construction pipeline.

---

## 6. Interactive Apps: Where the Same Pipeline Is Used

### 6.1 `spaceCraftEditor` (legacy full editor)

**Location:** `cpp/apps/OrbitalWar/spaceCraftEditor.cpp`

- Uses `EditSpaceCraft.h`, `SpaceCraft.h`, `SpaceCraft2Mesh2.h`, `MeshBuilder2.h`.
- Provides GUI (`SpaceCraftGUI`, SDL/GL) for editing components and visualizing:
  - The assembled `SpaceCraft` structure.
  - Generated truss mesh (`Mesh::Builder2` + `Truss` / `TrussDynamics_*`).
  - Radiative interactions using `TriangleRayTracer` + `Radiosity`.
- Represents the **"everything wired together"** app: geometry, physics, and radiation in one interactive tool.

### 6.2 `SpaceCraftEditorNew` (newer editor on top of dynamics app)

**Location:** `cpp/apps/OrbitalWar/SpaceCraftEditorNew.cpp`

- Derives from `SpaceCraftDynamicsApp` (shared simulator front‑end). 
- Reuses the same core pipeline under the hood:
  - Initializes workshop and Lua via `init_workshop()` and `initSpaceCraftingLua()`.
  - On startup: loads a default Lua ship (`data/ship_ICF_marksman_2.lua`) and runs the full initialization (`simulator->initSimulators()` → mesh build + truss setup).
- Adds dedicated GUI panels for components, girders, plates, and a Lua‑file dropdown powered by `Tree` utilities.

### 6.3 `spaceCraftDynamics`

**Location:** `cpp/apps/OrbitalWar/spaceCraftDynamics.cpp`

- Focuses on **dynamics simulation** and test configurations rather than full editing.
- Provides scripted setup helpers:
  - `make_Skeleton(...)` to generate nodes and girders directly into `SpaceCraft` (without Lua), then run `BuildCraft_blocks`.
  - Custom test commands (`-oct_nodes`, `-cube_nodes`) that:
    - Build a simple node/girder network.
    - Optionally attach wheels (`make_Ring2`) and sliders.
    - Call `BuildCraft_blocks`, then initialize simulations and slider constraints:
      - `o->updateSlidersPaths(...)` on `Ring`s.
      - `sliders2edgeverts(*theSpaceCraft, W.sim)` and `applySliders2sim` for per‑step constraints.
- Uses `SpaceCraftSimulator`/`SpaceCraftDynamicsApp` to manage `TrussDynamics_d/_f` and visualization.

### 6.4 `constructionBlockApp`

**Location:** `cpp/apps/OrbitalWar/constructionBlockApp.cpp`

- Demonstrates and stress‑tests **ConstructionBlock → MeshBuilder2** workflows:
  - High‑level `BlockBuilder` skeleton → `ConstructionBlockToMeshBuilder` → `Mesh::Builder2`.
- Closely related conceptually to `BuildCraft_blocks`:
  - Nodes = `ConstructionBlock`s.
  - Girders = logical edges → `bridge_quads` / `bridgeFacingPolygons`.
- Serves as the main reference and playground for the block‑based design ideas that were later adapted into the `SpaceCraft` pipeline.

---

## 7. Downstream Simulation & Analysis (Context Only)

These parts are **less central for the current task**, but important context:

- **Truss dynamics**
  - Code: `cpp/common/dynamics/TrussDynamics_d.h` (+ `_f`, `.cpp`).
  - Import helper: `loadSimFromFile(const char* fname, TrussDynamics_d& sim);`  
    Reads truss files written by `exportSimToFile` (see `spaceCraft_mesh_export_cli.md`).
  - Apps: `spaceCraftDynamics.cpp`, `trussSimBatch.cpp` (headless batch solver).

- **Radiative heat transfer & scattering**
  - Triangle occlusion & radiosity:
    - `TriangleRayTracer.h`, `Radiosity.h`, kernels documented in `docs/TriangleOcclusionRaytracer.md`.
  - Scattering solvers:
    - `Scatterer.h` and `Scatterer2.h`, compared in `docs/ScatteringSolverComparison.md`.
  - These consume meshes or surface elements derived (directly or indirectly) from `Mesh::Builder2` geometry.

The important architectural point: **SpaceCraft building and mesh generation are decoupled from simulation engines and solvers.** Export/import helpers sit at the module boundaries instead of forming a monolithic I/O layer.

---

## 8. Current State & Next Documentation Steps

**Current state (summary):**

- Lua → `SpaceCraft` construction via `EditSpaceCraft.h` is well‑defined and reused by several apps.
- The **block‑based mesh builder** (`BuildCraft_blocks`) is the primary path for modern spacecraft hulls, built on top of `Mesh::Builder2` and ideas from the `ConstructionBlock` system.
- Legacy truss builders (`BuildCraft_truss` / `SpaceCraft2Truss`) still exist and are important for understanding sliders and older ships, but new work should likely target the block‑based path.
- Headless tools (`spaceCraftMeshExport`, `trussSimBatch`) encapsulate clean pipelines for CI/testing and batch workflows.
- Radiation/scattering tools are present and partially integrated, but can be treated as separate consumers of the mesh.

**Planned refinements for this doc (to be detailed later):**

- More precise mapping table: **Lua function ↔ C++ builder ↔ component fields set ↔ mesh ranges touched**.
- Dedicated section on **Slider/Path lifecycle** from Lua → mesh → `TrussDynamics` constraints.
- Detailed walkthrough of **BuildCraft_blocks** internals (per component type) with code pointers.
- Cookbook‑style "how to add a new spacecraft component" using existing patterns.

---

## 9. Open Issues & Design Challenges (B–F) with Code References

This section collects the main open challenges discussed so far, restates them more systematically, and links each one to specific code locations. It is intended as a starting point for focused debugging and design work, not as an exhaustive description.

### 9.1 B – Old truss generator vs. new block‑based generator

- **Problem statement**
  - Legacy generator (`BuildCraft_truss`) uses **point‑like nodes** and girders that connect at single vertices.
  - This makes ships **wobbly**: joints only constrain distances, not rotation/bending/torsion, so vibration modes are hard to damp and simulations can be unstable.
  - The new `BuildCraft_blocks` generator reworks the system to use **solid blocks** (e.g. cubes/octahedra) as nodes, with girders attached to **faces / multiple vertices** to provide bending/torsion stiffness.
  - Open work: fully migrate all relevant components (ropes, sliders, plates, welds, modules) to the block‑based representation and verify that dynamic behavior is improved.

- **Key code locations**
  - Legacy truss generator:
    - `cpp/common/Orbital/SpaceCraft2Mesh2.h`
      - `void BuildCraft_truss(Builder2& mesh, SpaceCraft& craft, double max_size=-1);`
      - Helpers like `node_to_mesh(Node* o, Builder2& mesh)`, `girder_to_mesh(Girder* o, Builder2& mesh)`, `rope_to_mesh(Rope* o, Builder2& mesh)`, `ring_to_mesh(Ring* o, Builder2& mesh)`.
      - `weld_to_mesh(Weld* o, Builder2& mesh)` uses `mesh.bondsBetweenVertRanges(...)` to connect components by proximity.
  - Block‑based generator (full, spacecraft‑aware version):
    - `cpp/common/Orbital/SpaceCraft2Mesh2.h`
      - `void BuildCraft_blocks(Builder2& mesh, SpaceCraft& craft, double max_size=-1, double node_scale=1.0);`
      - Performs multiple passes:
        - Node blocks: `nodeBlock_to_mesh(Node* o, Builder2& mesh, SpaceCraft* craft)`.
        - Girder bridges: `girderBlocks_to_mesh(Girder* o, Builder2& mesh, SpaceCraft* craft)` – uses `chunkRange`s and face matching.
        - Rings: `ring_to_mesh(Ring* o, Builder2& mesh)`.
        - Slider anchors: `slider_to_mesh(Slider* o, Builder2& mesh)` (uses `make_anchor_point`).
        - Ropes: `rope_to_mesh(Rope* o, Builder2& mesh)`.
      - Currently **radiators, shields, welds, tanks, thrusters** are either commented out or left as TODOs in this function.
  - Block‑based generator (standalone truss‑view / simplified version):
    - `cpp/common/Orbital/SpaceCraft2Mesh_blocks.h`
      - Inline helpers `node_to_mesh`, `girder_to_mesh`, `ring_to_mesh`, `slider_to_mesh`, `rope_to_mesh`.
      - `inline void BuildCraft_blocks(Builder2& mesh, SpaceCraft& craft, double max_size=-1, double node_scale=1.0);`
      - `inline int checkSpaceCraftMesh(const Builder2& mesh, const SpaceCraft& craft, ...)` to catch unconnected vertices.

- **Status summary**
  - **Legacy truss path**: functionally complete, includes radiators and welds, but physically unstable (point joints).
  - **Block‑based path**: core structural components (nodes, girders, rings, sliders, ropes) are implemented; other components (plates, welds, tanks, thrusters) are still being ported.
  - The transition from point‑based to block‑based nodes is the main architectural fix for wobbliness, but requires careful treatment of attachments to all other components.

### 9.2 C – Sliders, paths, and glue to `TrussDynamics_d` (EdgeVertBond)

- **Problem statement**
  - Sliders and their paths are historically one of the most fragile parts of the system.
  - Sliders move along **paths defined as polylines** on the mesh (typically edges on girders or rings). The path is represented as a list of vertex indices plus a continuous parameter.
  - In the dynamics engine (`TrussDynamics_d`), sliders are coupled to the truss via **`EdgeVertBond`** constraints:
    - These bonds are treated as **external soft constraints** (not regular truss edges), applied in `TrussDynamics_d::run_LinSolve`.
  - Known issues:
    - The logic for picking the correct **side of a girder** and mapping that side into a vertex sequence (`sideToPath`) has been historically buggy.
    - Path interpolation is currently **linear** between mesh vertices; movement could be smoother with splines (Hermite/B‑spline), especially for long rails.
    - When exporting a `.truss` file (text format), current tooling **does not export the auxiliary EdgeVertBond / driver data**; a ship reconstructed only from the truss file can lose its sliders/wheels, effectively “falling apart”.

- **Path representation and side‑finding**
  - `cpp/common/Orbital/SpaceCraftComponents.h`
    - `class Slider : public Node`
      - Field `Path path;` with `int n; int* ps; double cur; bool closed;` etc.
      - `void updatePath(StructuralComponent* o, int side=-1);`
      - `inline void move(double dt, double l, double v, double f);` – simple 1D motor model along the path parameter.
    - `class Girder : public NodeLinker`
      - `virtual int nearSide(Vec3d p, const Mat3d* rot=0) const override;` – chooses which of 4 sides (0–3) is closest to a given point.
      - `virtual int sideToPath(int side, int*& inds, bool bAlloc=true, int nmax=-1) const override;` – builds a vector of vertex indices for that side:
        - Assumes `pointRange` covers all girder vertices, **4 vertices per segment**, tightly packed.
        - Checks `n == nseg` and `mseg == 4`, and fills `inds[i] = pointRange.x + 4*i + side;`.
    - `class Ring : public StructuralComponent`
      - `sideToPath` similarly assumes 4 verts per segment within `pointRange`.
    - `class Rope : public NodeLinker`
      - `sideToPath` uses a simpler layout (1 vertex per segment) and logs debug info.
    - `void StructuralComponent::updateSlidersPaths(bool bSelf, bool bShared, Quat4d* ps);`
      - Iterates over `nodes` looking for attached `Slider` nodes.
      - Chooses whether the rail is on `this` component or a bound component.
      - Uses `findNearestPoint` to determine initial path segment and side index.
      - Calls `sl->updatePath(...)`, optionally binds shared paths between multiple sliders.

- **Slider ↔ dynamics glue (`EdgeVertBond`)**
  - `cpp/common/dynamics/TrussDynamics_d.h`
    - `struct EdgeVertBond { Vec3i verts; double c; double K; Vec3d f; };`
      - `verts.x` and `verts.y`: indices of truss vertices forming the segment on the path.
      - `verts.z`: index of the **slider anchor vertex** (`Slider::ivert`).
      - `c`: interpolation parameter along the edge (0..1).
      - `K`: stiffness of the bond; `f` stores current force along the bond.
    - `void sliders2edgeverts(SpaceCraft& craft, TrussDynamics_d& sim);`
      - Allocates `sim.edgeVertBonds` to match `craft.sliders.size()`.
      - For each `Slider* o`:
        - Uses `o->path.fromCur(ev.verts.x, ev.verts.y)` to find the current segment and parameter `c`.
        - Sets `ev.verts.z = o->ivert; ev.c = ...; ev.K` to a large value.
    - `void applySliders2sim(SpaceCraft& craft, TrussDynamics_d& sim, double* control_speed);`
      - For each slider:
        - Computes segment direction and relative velocity.
        - Feeds current force/velocity into `Slider::move(...)` to update the path parameter.
        - Updates the corresponding `EdgeVertBond` (`verts`, `c`) for the next iteration.

- **Export gaps**
  - `cpp/common/Orbital/SpaceCraft2Mesh_blocks.h`
    - `inline void exportSimToFile(const char* fname, const Builder2& mesh, const SpaceCraftWorkshop& shop);`
      - Writes only:
        - `meta` line (npoint, nbond).
        - `p` lines (point positions, mass, nneigh).
        - `s` lines (bonds with kpull, kpush, l0, damping).
      - Does **not** serialize any `EdgeVertBond` / slider driver info.
  - For long‑term robustness, a future extension of the text truss format should include an optional block for slider/path constraints.

### 9.3 E – Plates (radiators, shields) and structural stiffness

- **Problem statement**
  - Plates such as **radiators** and **shields** are only partially implemented in the newer block‑based pipeline.
  - Open design issues:
    1. **Attachment**: how exactly to attach plates to girders (or ropes) so that tessellation matches and loads transfer correctly.
       - High‑level idea: select positions along girders (by fraction or segment index) and generate a triangular grid between those lines.
       - Challenge: this implies either matching segment counts along both sides or handling mismatched tessellation.
    2. **Offset vs. flush**: should plates be inset/offset from the main truss and connected via auxiliary sticks, or directly share vertices/edges with girders?
    3. **Bending stiffness**: for some plates (e.g. shields, pusher plates) we need non‑zero thickness and flexural stiffness; for others (radiators, sails) a thin membrane might be sufficient.

- **Current implementation / utilities**
  - Legacy truss pipeline:
    - `cpp/common/Orbital/SpaceCraft2Mesh2.h`
      - `BuildCraft_truss` includes:
        - `for(Radiator* o : craft.radiators){ radiator_to_mesh(o, mesh, &craft); }` – radiators are hooked into the old truss path.
        - Shields and more advanced plates are present only as commented TODOs.
  - Block‑based pipeline:
    - `cpp/common/Orbital/SpaceCraft2Mesh2.h`
      - `BuildCraft_blocks` currently comments out radiators, shields, and welds.
      - These components exist in `SpaceCraft` and `SpaceCraftComponents.h` but are not yet generated into the block‑based mesh.
  - Slab/plate geometry generators:
    - `cpp/apps/OrbitalWar/constructionBlockApp.cpp`
    - `cpp/common_SDL/SDL2OGL3/DrawUV.h`
      - Contain and exercise **slab and disk generators** with UV mapping, including double‑layer slabs with cross links.
      - These are promising building blocks for structurally stiff plates (e.g. shield/pusher plate, thick structural radiators).
  - `Mesh::Builder2` helpers:
    - `cpp/common/geometry/MeshBuilder2.h`
      - Includes primitives like `triangle_strip`, `bridge_quads`, `panel`, and high‑level helpers for connecting faces/strips.

- **Status summary**
  - Geometry tools for both thin and thick plates already exist and are tested in auxiliary apps.
  - Old truss pipeline has radiators wired in; new block pipeline does not yet.
  - A future refactor should define a clear pattern: for each `Plate` component,
    - how to select anchor lines on supporting structures,
    - how to generate the plate mesh (thin vs slab), and
    - how to store `pointRange` / `stickRange` so the plate can participate in dynamics.

### 9.4 F – Nozzles / dishes (pusher plates, magnetic nozzles) and connections

- **Problem statement**
  - Thrusters in realistic designs often involve **large disks or dishes**:
    - Pusher plates (Orion‑like nuclear pulse craft).
    - Magnetic nozzles / parabolic reflectors (e.g. Daedalus‑like). 
  - These structures must be:
    - **Geometrically** correct (disk/paraboloid) and possibly thick.
    - **Mechanically** attached to the main truss in a way that allows the right amount of damping:
      - Large‑amplitude damping: ropes/soft connectors.
      - Small‑amplitude damping: special “dampler” stick materials (still rigid topologically).
  - Open questions:
    - Should connections be made **manually** (connecting specific vertices) or **automatically** (e.g., via weld‑like generators)?
    - How to strike the balance between robustness (many connections for stiffness) and controllable damping.

- **Current implementation / tools**
  - Geometry generators for disks/dishes and slabs:
    - `cpp/apps/OrbitalWar/constructionBlockApp.cpp`
    - `cpp/common_SDL/SDL2OGL3/DrawUV.h`
      - Implement and test functions for building disks, parabolic dishes, and double‑layer slabs with cross links.
      - These are suitable for both **shields** and **nozzle/pusher plates**.
  - Connection and damping mechanisms:
    - **Ropes**:
      - `SpaceCraftComponents.h` → `class Rope` with `nseg`, `thick`, and `component_kind()`.
      - `SpaceCraft2Mesh2.h` / `SpaceCraft2Mesh_blocks.h` → `rope_to_mesh` using `mesh.rope(...)`.
      - `SpaceCraft2Mesh2.h::exportSim(TrussDynamics_d&, ...)`:
        - Edges whose `StickMaterial` name starts with `"rope"` are automatically added to `sim.damped_bonds` and `sim.damped_points`.
        - This provides material‑level control over damping.
    - **Sticks with damping materials**:
      - `StickMaterial` in `SpaceCraftComponents.h` / `SpaceCraftWorkshop` controls stiffness and damping.
      - Specialized materials can be defined for “dampler” sticks used in nozzle attachments.
    - **Weld/auto‑connection between components**:
      - `SpaceCraftComponents.h` → `class Weld` stores references to two components and parameters like `Rmax` and `face_mat`.
      - `SpaceCraft2Mesh2.h::weld_to_mesh(Weld* o, Builder2& mesh)`:
        - Calls `mesh.bondsBetweenVertRanges(o->comps.x->pointRange, o->comps.y->pointRange, o->Rmax, o->face_mat);`
        - Updates `o->pointRange` / `o->stickRange` for the weld itself.
      - This is the current **automatic connector**: within a bounding region and distance threshold, connect all eligible vertex pairs between two components.

- **Status summary**
  - Geometric primitives for nozzles/dishes exist and are tested, but there is no dedicated `Thruster`/nozzle mesh builder wired into `BuildCraft_blocks` yet.
  - Damping strategies can be expressed via ropes and special stick materials, and auto‑connection via welds is already implemented.
  - Missing piece is a high‑level pattern: for a given thruster/dish component, how to:
    - Generate its mesh (disk/paraboloid, thin vs thick).
    - Choose attachment strategy (ropes vs damped sticks vs welds).
    - Encode these connections in both the mesh (`pointRange` / `stickRange`) and the exported simulation formats.

---

## 10. Links to Space‑Warfare Physics Model

The **space‑warfare encyclopedia** in `encyclopedia/space_warfare/` provides the *game design and physics whitepaper* that the spacecraft code should eventually implement. This section notes where those concepts connect to current code or obvious extension points.

- **Tactics, propulsion and kinematics**  
  Docs:
  - `00_Overview.md` (sections 1, 4, 5)
  - `07_Physical_model_and_equations.md` – sections 1–2, 5
  Connections:
  - Ship‑level parameters like \(\Delta v\), long‑term \(\bar{a}\) and peak \(a_\text{max}\) correspond to:
    - **Mass and force limits** in `TrussDynamics_d` / `_f` (per‑edge stiffness and damping from `StickMaterial`, gravity/accel fields).
    - **Propulsion subsystems** modelled as `Thruster` components in `SpaceCraftComponents.h` (currently mostly geometry + catalog data).
  - The **rocket equation and power/\(v_e\) trade‑offs** (07_Physical_model, sec. 2) can feed into:
    - A higher‑level ship‑stats layer (not yet implemented here) that computes effective \(\Delta v\), \(\bar{a}\) and \(a_\text{max}\) from `SpaceCraft` mass and installed thrusters.
    - Scenario tools that configure `spaceCraftDynamics` initial conditions from those aggregate stats.

- **Laser / particle beams and radiative effects**  
  Docs:
  - `07_Physical_model_and_equations.md` – sections 3–4, 6
  - `docs/TriangleOcclusionRaytracer.md`, `docs/ScatteringSolverComparison.md`
  Connections:
  - Beam diffraction, intensity vs. range and shield erosion models are implemented or planned via:
    - `TriangleRayTracer.h` + `Radiosity.h` (occlusion, radiosity, thermal balance) consuming meshes from `Mesh::Builder2`.
    - `Scatterer.h` / `Scatterer2.h` for scattering simulations.
  - The **thin‑shield erosion** and **probabilistic active defence** formulas can be mapped onto:
    - Material properties of `Shield` / `Radiator` plates (`SpaceCraftComponents.h`), once their meshes are generated consistently by `BuildCraft_blocks`.
    - Higher‑level game logic (not yet in this repo) that uses element‑level fluxes from the radiosity / scattering solvers to update shield integrity.

- **Kinetic projectiles and structural loads**  
  Docs:
  - `07_Physical_model_and_equations.md` – sections 5, 8
  Connections:
  - Projectile ballistics (force‑ or power‑limited launchers, optimal velocity) sit mostly *outside* the spacecraft builder, but their **impact loads** translate into:
    - External forces and impulses applied to `TrussDynamics_d` points/edges.
    - Structural limits derived from `StickMaterial` and `Material` catalogs in `SpaceCraftComponents.h` (tension limits, damping ⇒ max safe \(a_\text{max}\), spin rates).
  - The simple structural formulas (sec. 8) directly justify the **truss‑/tether‑centric architecture** of `SpaceCraft` and the emphasis on ropes vs beams in ship construction.

In summary, `SpaceCraft` + `Mesh::Builder2` supply the **geometric and structural substrate** on which the space‑warfare physics from `07_Physical_model_and_equations.md` should act. The current code covers mainly geometry and elastic truss dynamics; ship‑level \(\Delta v\), weapon performance, and shield erosion live mostly in these documentation files and are intended as guidance for future gameplay/AI layers built on top of this core.

