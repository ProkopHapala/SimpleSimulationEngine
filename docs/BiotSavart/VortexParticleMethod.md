https://aistudio.google.com/app/prompts?state=%7B%22ids%22:%5B%221YZ0qjlye5lOO8r_KwR9HOisvPmfYu66u%22%5D,%22action%22:%22open%22,%22userId%22:%22100958146796876347936%22,%22resourceKeys%22:%7B%7D%7D&usp=sharing

## USER

There are potential flow solvers (like vortex lattice methods using horse-shue vortex filaments and no time) and there are fluid dynamics solvers using grids finite elements and propagation in time. I'm thinking about making some hybrid. Basically create the vortex filaments as a chain of point vortices (like dipole but with cross-product - something which can be evaluated cheaply), and let them propagate and advect (move) by the velocity filed generated by the others. The problem is that this produce "dense" matrix as the fundamental solutions are extended ins space and decaying like 1/r or 1/r^3 (like dipole right? resp dipole-dipole? 1/r^5 anyway). I was thinking to use some fast multipole method or Partcile mesh evald to solve them.

I'm a bit inspired by "schroending smoke"
https://github.com/linwe2012/SchroedingerSmoke
https://cseweb.ucsd.edu/~alchern/projects/SchrodingersSmoke/
https://dl.acm.org/doi/10.1145/2897824.2925868

but that work completely on grid using FFT (like eulerian). I was basically thinking about Lagrangeion alternative (chan we shay that?). The advantage is that my basis is smaller (I can constrain the basis - it is like in molecular dynamics Plane-Waves absis set wich describe vacuum with same density as the molecule, versus LCAO). Also the movement of vortex filaments (as particles) alolows very nice interpetation and analysis (debugging) and I can apply regularization easily (e.g. say the vortex core disipate behind the aircraft, and the vortex filement does not want to bend - it is like stiff string), theis should stabilize the simulation, at the cost of lower resolution (lower sharpness of the velocity field)


---

## Gemnini

You are describing a well-established and powerful branch of Computational Fluid Dynamics (CFD) called **Vortex Methods** (specifically, the **Vortex Filament Method** or **Vortex Particle Method**).

Your intuition is spot on. You are essentially reinventing the 3D Lagrangian approach to fluid dynamics, and your analogy about "LCAO vs. Plane Waves" is perfect for describing the trade-off between Vortex Methods (Lagrangian) and Grid Methods (Eulerian).

Here is a breakdown of your ideas, how they map to existing physics, and how to solve the computational bottlenecks you identified.

### 1. Concept Verification: Is this a "Lagrangian Alternative"?
**Yes.**
*   **Eulerian (Grid):** Like "Plane Waves." You define the field everywhere, even where nothing is happening (vacuum). This is what *Schrödinger's Smoke* does.
*   **Lagrangian (Particle/Filament):** Like "LCAO" (Linear Combination of Atomic Orbitals). You only place computational elements where the "matter" (vorticity) is.

The approach you are describing—representing the flow as a chain of discretized points (nodes) connected to form filaments—is the standard **3D Vortex Filament Method**.

### 2. The Physics: Biot-Savart and Decay Rates
You mentioned the "dipole" and cross-products. This is mathematically precise. The velocity induced by a vortex filament is given by the **Biot-Savart Law** (identical to electrodynamics, where vorticity $\omega$ replaces current $I$, and velocity $u$ replaces magnetic field $B$).

The velocity $\mathbf{u}$ at a position $\mathbf{x}$ induced by a vortex segment $d\mathbf{l}$ with circulation $\Gamma$ is:

$$ \mathbf{u}(\mathbf{x}) = \frac{\Gamma}{4\pi} \int \frac{d\mathbf{l}' \times (\mathbf{x} - \mathbf{x}')}{|\mathbf{x} - \mathbf{x}'|^3} $$

*   **Decay Rate:** The kernel decays as $1/r^2$.
*   **Why you thought $1/r^3$:** A *point* vortex in 3D is not physically realizable (div $\omega \neq 0$), but a "vorticle" (vortex particle) acts somewhat like a dipole. However, the Biot-Savart interaction is fundamentally $1/r^2$.
*   **The Cross Product:** Your intuition about the "cross-product" is correct. The velocity is perpendicular to both the filament direction and the distance vector.

### 3. Solving the $N^2$ "Dense Matrix" Problem
As you correctly noted, if you have $N$ vortex nodes, calculating the velocity for every node by summing the influence of all other nodes is $O(N^2)$. This becomes too slow very quickly.

There are two main ways to solve this (your "Hybrid" idea):

#### A. Vortex-in-Cell (VIC) / Particle-Mesh (PM)
This is exactly what you alluded to with "Particle mesh evald."
1.  **Interpolate:** Interpolate the vorticity from your Lagrangian filaments onto a temporary background grid.
2.  **Solve:** Use FFTs (Poisson solver) on the grid to get the velocity field. This is $O(M \log M)$ where $M$ is grid size.
3.  **Differentiate:** Compute velocity at grid points.
4.  **Interpolate Back:** Interpolate velocity back to the filament nodes to move them.

*   **Pros:** Very fast.
*   **Cons:** You reintroduce a grid, limiting your resolution to the grid spacing (hybrid approach).

#### B. Fast Multipole Method (FMM) / Tree Codes
This is the "pure" Lagrangian solution (no grid).
Instead of calculating every pair, you group distant particles into "clusters." You treat a distant cluster as a single effective multipole expansion.
*   **Barnes-Hut:** $O(N \log N)$ approximation.
*   **FMM (Greengard-Rokhlin):** $O(N)$ precision.

This allows you to keep the "infinite domain" (no box boundaries) and the sparse representation.

### 4. Your "Schrödinger" Inspiration & Regularization
You liked the stability of Schrödinger's Smoke. In Vortex Methods, we achieve stability through **Regularization (Desingularization)**.

The $1/r^2$ term blows up if two filaments get too close (singular). To fix this, we use "Vortex Blobs" (smoothing kernels). We replace the singular point with a core of radius $\sigma$:

$$ \frac{1}{|\mathbf{r}|^3} \rightarrow \frac{1}{(|\mathbf{r}|^2 + \sigma^2)^{3/2}} $$

**Regarding your "Stiff String" idea:**
You mentioned treating the filament as a "stiff string" to prevent bending.
*   **Caution:** In fluid dynamics, **vortex stretching** is the primary mechanism of turbulence (energy cascade). If you artificially prevent the filaments from stretching and twisting, you kill the turbulence.
*   **The Real Problem:** The real issue is that as filaments stretch, the nodes get too far apart.
*   **The Solution (Filament Resampling):** You must dynamically insert new nodes into the chain as it stretches to maintain resolution. This is called *remeshing* or *filament surgery*.

### 5. Implementation Roadmap (The "Lagrangian Alternative")

If you want to build this, here is the architectural path:

1.  **Data Structure:** A list of linked lists (chains of nodes). Each node has Position $\mathbf{x}$ and Circulation vector $\mathbf{\Gamma}$.
2.  **Interaction (The Solver):**
    *   *Start:* Brute force $O(N^2)$ Biot-Savart summation.
    *   *Upgrade:* Implement a **Barnes-Hut Tree Code**. This is easier than FMM and usually fast enough for visual simulation.
3.  **Time Integration:** Runge-Kutta 2 (RK2) or RK4. Vortex dynamics are sensitive; Euler integration will make them spiral out of control.
4.  **Regularization:** Use the **Rosenhead-Moore** or **Winckelmans** high-order smoothing kernels to prevent explosions when filaments cross.
5.  **rendering:** You can generate a "skin" around the filaments or spawn tracer particles (smoke) that just passively follow the calculated velocity field.

### Summary
You are describing a **Vortex Filament Method accelerated by FMM or P3M**. This is a scientifically valid, highly optimized approach used in aerodynamics (wake vortex simulations) and computer graphics (smoke, explosions).

It is superior to Grid/FFT methods (like Schrödinger's Smoke) for:
1.  **Open boundaries** (an aircraft flying in infinite sky).
2.  **Wake dynamics** (detailed swirling far behind the object).
3.  **Sparse flow** (where most of the volume is empty air).

---

## USER

How exactly we would implement the Fast multipole method for this system. Resp. lets make is simpler. I can pre-define clusters of the vortex primitives (particles), we do not want to do hierarchy (tree) but only one level, it will reduce complexity from N^2 to K^2 or K*N where N is number of primitives (particles) and N is number of clusters. (I would prefer solution which reduces it to K^). Our N and K will not be so high so asymptotic O(Nlog(N)) is not worth the cost of more complicated locgick and lower cache locality (especially on GPU).

I always struggli in these pliting algorithms both FMM and P3M to figure out how it should be splited corretly physically, what exactly is the kernel evaluate for particle-particle particle-cluster and cluster-cluster, and how to match them smoothly so there are no jumps if I get beyond cutoff radius. Can you do it for me in rigourous way for this case?

---

## Gemini


To implement a **Single-Level Fast Multipole Method (FMM)** that runs efficiently on a GPU with $O(K^2)$ complexity for the far-field, we need to abandon the complex tree structure and use a **Tile-Based (or Block-Based) approach**.

This approach splits the problem into **Near-Field (Direct P-P)** and **Far-Field (Cluster-Cluster M2L)**.

Here is the rigorous derivation and implementation strategy.

---

### 1. The Physics: Vector Potential vs. Velocity
Directly expanding the Biot-Savart velocity kernel ($\mathbf{r} \times d\mathbf{l} / r^3$) is messy because it is a tensor interaction.
Instead, we rely on the mathematical identity that velocity $\mathbf{u}$ is the curl of the vector potential $\mathbf{A}$:
$$ \mathbf{u}(\mathbf{x}) = \nabla \times \mathbf{A}(\mathbf{x}) $$
$$ \mathbf{A}(\mathbf{x}) = \frac{1}{4\pi} \sum_{j} \frac{\mathbf{\Gamma}_j d\mathbf{l}_j}{\sqrt{|\mathbf{x} - \mathbf{y}_j|^2 + \sigma^2}} $$

Where $\mathbf{L}_j = \mathbf{\Gamma}_j d\mathbf{l}_j$ is the **strength vector** of the vortex segment.

**Strategy:** We will perform the Multipole expansion on the scalar $1/r$ kernel (applied to each of the 3 components of $\mathbf{L}_j$), sum them up, and analytically take the curl at the very end to get velocity.

---

### 2. The Algorithm: Single-Level FMM
We divide the world into a grid of $K$ cubic clusters (tiles).
Let $N$ be total particles. Let $M$ be particles per cluster ($N = K \times M$).

#### Phase 1: P2M (Particle to Multipole) - $O(N)$
For each Cluster $C$ (centered at $\mathbf{c}$), we compute its Multipole Moments. We aggregate the messy cloud of particles into a single compact representation located at $\mathbf{c}$.

We use a **Cartesian Taylor Expansion** up to order 2 (Monopole + Dipole + Quadrupole).
For a source particle at $\mathbf{y}$ inside the cluster, let $\mathbf{y}' = \mathbf{y} - \mathbf{c}$.

The moments for the cluster are:
1.  **Monopole (Vector $\mathbf{M}$):** The total vorticity.
    $$ \mathbf{M} = \sum_{j \in C} \mathbf{L}_j $$
2.  **Dipole (Tensor $\mathbf{D}$):** Displacement weighted by vorticity.
    $$ D_{\alpha\beta} = \sum_{j \in C} L_{j,\alpha} y'_{j,\beta} $$
    *(Indices $\alpha, \beta$ represent x, y, z)*
3.  **Quadrupole (Tensor $\mathbf{Q}$):**
    $$ Q_{\alpha\beta\gamma} = \sum_{j \in C} L_{j,\alpha} y'_{j,\beta} y'_{j,\gamma} $$

#### Phase 2: M2L (Multipole to Local) - $O(K^2)$
This is the "Dense Matrix" part you anticipated. We calculate how every Source Cluster $S$ affects every Target Cluster $T$.
Instead of calculating velocity directly, we translate the *Multipole expansion* of $S$ into a *Local Taylor expansion* at the center of $T$.

Let $\mathbf{R} = \mathbf{c}_T - \mathbf{c}_S$.
We construct a local coefficient vector $\mathbf{H}$ at target $T$ that represents the accumulated field from all distant clusters.

#### Phase 3: L2P + P2P (Evaluation) - $O(N \times \text{Neighbors})$
For a particle $\mathbf{x}$ inside Target Cluster $T$:
1.  **Far-Field:** Evaluate the Local Expansion polynomial $\mathbf{H}$ at $\mathbf{x}$.
2.  **Near-Field:** Perform brute-force Biot-Savart summation only for particles in $T$ and the 26 immediate neighbor clusters.

---

### 3. Rigorous Kernels and "Matching"

You asked about "smooth matching" to avoid jumps. In FMM, **we do not use blending functions** (like smoothstep) because they destroy the property that the field satisfies Laplace's equation ($\nabla^2 \phi = 0$).

Instead, we rely on the **Multipole Acceptance Criterion (MAC)**.
*   If distances are large (Cluster $S$ is not a neighbor of $T$), the error of the expansion drops as $(R_{cluster}/R_{dist})^{Order}$.
*   With Order 2 or 3, the jump at the boundary between "Neighbor" and "Far" is usually below $10^{-4}$, which is invisible in fluid dynamics.

#### The Far-Field Kernel (The Expansion)
We need $\mathbf{u}(\mathbf{x}) = \nabla \times \mathbf{A}$.
Let's expand $\frac{1}{|\mathbf{x} - \mathbf{y}|}$ where $\mathbf{x}$ is near target center $\mathbf{c}_T$ and $\mathbf{y}$ is near source center $\mathbf{c}_S$.
Let $\mathbf{R} = \mathbf{c}_T - \mathbf{c}_S$.

The Vector Potential contribution from Source Cluster $S$ to a point $\mathbf{x}$ in Target Cluster $T$ (where $\Delta \mathbf{x} = \mathbf{x} - \mathbf{c}_T$) is approximated by:

$$ A_\alpha(\mathbf{x}) \approx \underbrace{\frac{M_\alpha}{|\mathbf{R}|}}_{\text{Mono}} + \underbrace{\nabla_\beta \left(\frac{1}{|\mathbf{R}|}\right) D_{\alpha\beta}}_{\text{Dipole}} + \dots $$

*Wait, this computes $\mathbf{A}$. We need $\mathbf{u}$.*
Let's apply the Curl operator analytically to the coefficients so we calculate Velocity directly.
$\mathbf{u} = \nabla \times \mathbf{A} \implies u_i = \epsilon_{ijk} \partial_j A_k$.

**The Resulting "K-K" Interaction (Source $S$ to Target $T$):**
We compute the coefficients of the velocity field at $\mathbf{c}_T$.
Velocity at $\mathbf{x}$ is approx:
$$ \mathbf{u}(\mathbf{x}) \approx \mathbf{V}^{(0)} + [\mathbf{V}^{(1)}] \cdot \Delta \mathbf{x} $$

Where $\mathbf{V}^{(0)}$ is the constant velocity at the cluster center, and $\mathbf{V}^{(1)}$ is the velocity gradient (strain/rotation) at the center.

**The Math for the Coefficients (GPU Kernel):**
Let $G_0 = 1/|\mathbf{R}|$, $G_\beta = \partial_\beta (1/|\mathbf{R}|)$, $G_{\beta\gamma} = \partial_\beta \partial_\gamma (1/|\mathbf{R}|)$.

1.  **Base Velocity ($\mathbf{V}^{(0)}$):**
    $$ V^{(0)}_i = \epsilon_{ijk} \left( G_\beta D_{k\beta} + G_0 M_k \right) $$
    *(Note: The monopole term $G_0 M_k$ requires careful handling of the derivative. Actually, the term is $\epsilon_{ijk} \partial_j (M_k/R) = \epsilon_{ijk} M_k G_j$.)*

    Corrected 1st order approximation:
    $$ V^{(0)}_i = \epsilon_{ijk} \left( G_j M_k + G_{j\beta} D_{k\beta} + \frac{1}{2} G_{j\beta\gamma} Q_{k\beta\gamma} \right) $$

2.  **Velocity Gradient ($\mathbf{V}^{(1)}$):**
    This term allows the velocity to vary linearly across the target cluster.
    $$ V^{(1)}_{im} = \partial_m u_i = \epsilon_{ijk} \left( G_{jm} M_k + G_{jm\beta} D_{k\beta} \right) $$

**Total Far Field for particle $\mathbf{x}$:**
$$ u_i(\mathbf{x})_{far} = \sum_{S \in Far} \left( V^{(0)}_i(S) + V^{(1)}_{im}(S) \cdot \Delta x_m \right) $$

---

### 4. Implementation Steps

#### A. Data Structures
*   `Particles`: Arrays for `Pos` (vec3) and `Vorticity` (vec3).
*   `Cluster_Moments`: Array of size $K$. Struct `{ M (vec3), D (mat3), Q (tensor3) }`.
*   `Cluster_LocalField`: Array of size $K$. Struct `{ V_const (vec3), V_grad (mat3) }`.

#### B. Step 1: Compute Moments (P2M)
Launch one thread per particle. Determine which cluster $k$ it belongs to. Use `atomicAdd` to accumulate $\mathbf{L}$, $\mathbf{L} \otimes \mathbf{y}'$, etc., into `Cluster_Moments[k]`.

#### C. Step 2: Far-Field Pass (M2L) - The "Dense" Matrix
Launch one thread block (or thread) per Target Cluster $T$.
Loop over all Source Clusters $S$.
1.  Check distance $|\mathbf{c}_T - \mathbf{c}_S|$.
2.  **Matching Logic:**
    *   If $|\mathbf{c}_T - \mathbf{c}_S| < 1.5 \times \text{ClusterSize}$ (i.e., it is a neighbor): **SKIP**.
    *   Else: Compute the interaction using the "Corrected 1st order approximation" formula above.
3.  Sum results into `Cluster_LocalField[T]`.

*This reduces the $N^2$ problem to a $K^2$ problem.*

#### D. Step 3: Evaluation (L2P + P2P)
Launch one thread per particle $\mathbf{x}$ in Cluster $T$.
1.  **Far-Field:** Read `Cluster_LocalField[T]`.
    $$ \mathbf{u}_{far} = \mathbf{V}_{const} + \mathbf{V}_{grad} \cdot (\mathbf{x} - \mathbf{c}_T) $$
2.  **Near-Field:** Loop over the 27 clusters (Self + 26 Neighbors). Iterate through all particles in those clusters.
    $$ \mathbf{u}_{near} += \frac{\mathbf{L}_j \times (\mathbf{x} - \mathbf{y}_j)}{(|\mathbf{x} - \mathbf{y}_j|^2 + \sigma^2)^{3/2}} $$
    *(Using Rosenhead-Moore regularization)*.
3.  $\mathbf{u}_{total} = \mathbf{u}_{far} + \mathbf{u}_{near}$.

### 5. Why this works without "Jumps"
The jump occurs because in the Near-Field loop, we use the exact $1/r^2$ law, and in the Far-Field, we use the Taylor approximation.
However, at the boundary (distance $\approx 1.5 \times$ cell size), the Taylor series of order 2 (Quadrupole) matches the exact solution to very high precision.

If you observe jumps, simply **increase the cluster size slightly** or **include 2 layers of neighbors** (125 neighbors instead of 27) in the direct sum. The $5^3$ neighbor approach is standard in high-precision P3M codes to guarantee smoothness.

### Summary of Complexity
*   **Original:** $N^2$
*   **This Method:**
    *   Moment Sum: $N$
    *   Grid Interaction: $K^2$ (Very fast on GPU as $K \ll N$)
    *   Neighbor Interaction: $27 \times (N/K) \times N$
*   **Optimization:** You tune $K$ (grid size) such that the time for $K^2$ roughly equals the time for the neighbor search.

---

## USER

You are absolutely correct on both points.

1.  **Vector Potential:** Yes, $\mathbf{A}$ is a vector field. My previous explanation simplified it too much. Also, you are right to worry about decay rates: $\mathbf{A}$ decays as $1/r$, while velocity $\mathbf{u}$ decays as $1/r^2$. Summing terms that decay slowly ($1/r$) can lead to precision issues if we aren't careful, though mathematically the curl of the expansion corrects it. **However, we can skip $\mathbf{A}$ entirely and expand the Velocity Kernel directly.** This matches your intuition better.
2.  **No Grid / Random Clusters:** If you have unstructured clusters (point clouds), we cannot use "fixed neighbors." We must use a dynamic **Multipole Acceptance Criterion (MAC)** based on bounding spheres.

Here is the rigorous implementation for **Unstructured Clusters** working directly with **Velocity**, ensuring no "jumps" and $O(K^2)$ complexity.

---

### 1. The Physics: Direct Velocity Expansion
We want to solve the Biot-Savart law:
$$ \mathbf{u}(\mathbf{x}) = \frac{1}{4\pi} \sum_j \mathbf{\Gamma}_j \times \frac{\mathbf{x} - \mathbf{y}_j}{|\mathbf{x} - \mathbf{y}_j|^3} $$

This looks exactly like the magnetic field of a dipole. A small vortex segment *is* a dipole of velocity.
Let's define the moments of a Cluster $C$ centered at $\mathbf{c}$. Let $\mathbf{y}' = \mathbf{y}_j - \mathbf{c}$.

#### The Moments (Source Description)
1.  **Total Vorticity ($\mathbf{\Omega}$ - "Monopole"):**
    $$ \mathbf{\Omega} = \sum_{j \in C} \mathbf{\Gamma}_j $$
2.  **First Moment ($\mathbf{T}$ - "Dipole"):**
    This encodes the displacement of vorticity within the cluster. It is a Tensor (Matrix).
    $$ T_{\alpha\beta} = \sum_{j \in C} \Gamma_{j,\alpha} y'_{\beta} $$
    *(Indices $\alpha, \beta \in \{x,y,z\}$)*

---

### 2. The Algorithm: Unstructured Split

Since we don't have a grid, we define interactions based on the **Opening Angle** or **Bounding Spheres**.

Let every cluster $C_i$ have:
*   Center $\mathbf{c}_i$
*   Radius $r_i$ (radius of bounding sphere enclosing all its particles)

#### The Split Logic (MAC)
For every pair of clusters $A$ and $B$:
Calculate distance $R = |\mathbf{c}_A - \mathbf{c}_B|$.
We define a safety parameter $\theta$ (usually $1.5$ to $2.0$).

**The Condition:**
$$ R > \theta \cdot (r_A + r_B) $$

*   **If TRUE (Far-Field):** Use the Multipole approximation. The error is proportional to $(\frac{r_A+r_B}{R})^3$. With $\theta=2$, the error is $< 1/8$ for lowest order, but drops drastically with higher orders.
*   **If FALSE (Near-Field):** The clusters are too close. We must compute direct particle-to-particle interactions between all particles in $A$ and all in $B$.

---

### 3. The Kernel: Cluster-to-Cluster (Far Field)

Here is the explicit math for the force a Source Cluster $S$ exerts on a target point $\mathbf{x}$ (centered at $\mathbf{c}_T$).
Let $\mathbf{R} = \mathbf{x} - \mathbf{c}_S$.

To get $O(K^2)$, we need to evaluate the field at the Target Center $\mathbf{c}_T$ and its gradient (Local Expansion), then apply it to particles in $T$.

**Term 1: The "Monopole" Interaction (Decays as $1/R^2$)**
(This is treating the cluster as a single point vortex).
$$ \mathbf{u}^{(0)} = \frac{1}{4\pi} \frac{\mathbf{\Omega} \times \mathbf{R}}{|\mathbf{R}|^3} $$

**Term 2: The "Dipole" Correction (Decays as $1/R^3$)**
(This accounts for the shape of the cluster).
$$ u_\gamma^{(1)} = \frac{1}{4\pi} \epsilon_{\gamma\alpha\mu} T_{\alpha\beta} \partial_\beta \left( \frac{R_\mu}{R^3} \right) $$

*Calculated explicitly:*
$$ \partial_\beta \left( \frac{R_\mu}{R^3} \right) = \frac{\delta_{\beta\mu}}{R^3} - \frac{3 R_\beta R_\mu}{R^5} $$

So the velocity correction vector $\mathbf{u}^{(1)}$ is:
$$ u_\gamma^{(1)} = \frac{1}{4\pi} \epsilon_{\gamma\alpha\beta} \frac{T_{\alpha\beta}}{R^3} - \frac{3}{4\pi} \frac{(\mathbf{\Omega} \times \mathbf{R})_\gamma (\mathbf{T} : \mathbf{R}\mathbf{R})}{R^5} \dots (\text{Conceptual simplification}) $$
*Actually, just implement the derivative summation in code, it's safer.*

---

### 4. Implementation Strategy (GPU Friendly)

Since branching `if (far) else (near)` inside a GPU kernel kills performance, we split the work into lists.

#### Phase 1: Build Interaction Lists (CPU or Compute Shader)
Input: List of Clusters (Center, Radius).
Output: Two lists for each Cluster $i$.
1.  `FarList_i`: Indices of clusters satisfying $R > \theta(r_i+r_j)$.
2.  `NearList_i`: Indices of clusters failing the check.

*Note: Since $K$ is small (e.g., 100-1000), this $K^2$ check is instantaneous.*

#### Phase 2: Compute Moments (P2M)
Parallel over Particles. Atomic add to Cluster Moments ($\mathbf{\Omega}, \mathbf{T}$).

#### Phase 3: Far-Field Evaluation (M2L)
Parallel over Clusters ($i$).
Loop over `FarList_i` ($j$).
1.  Calculate $\mathbf{R} = \mathbf{c}_i - \mathbf{c}_j$.
2.  Evaluate $\mathbf{V}_{base} = \text{Kernel}(\mathbf{\Omega}_j, \mathbf{T}_j, \mathbf{R})$.
3.  Evaluate Gradient $\nabla \mathbf{V} = \text{GradKernel}(\dots)$.
4.  Store $\mathbf{V}_{base}$ and $\nabla \mathbf{V}$ in a `LocalField` buffer for Cluster $i$.

#### Phase 4: Particle Update (L2P + Direct P2P)
Parallel over Particles (particle $p$ in cluster $i$).

1.  **Apply Far Field:**
    Read `LocalField[i]`.
    $$ \mathbf{u}_p = \mathbf{V}_{base} + \nabla \mathbf{V} \cdot (\mathbf{x}_p - \mathbf{c}_i) $$

2.  **Apply Near Field (The Correction):**
    Loop over clusters in `NearList_i` ($k$).
    Loop over particles $q$ in Cluster $k$.
    $$ \mathbf{u}_p \leftarrow \mathbf{u}_p + \frac{\mathbf{\Gamma}_q \times \mathbf{r}_{pq}}{(r_{pq}^2 + \sigma^2)^{3/2}} $$

### 5. Solving the "Jump" (Smooth Matching)

You asked how to match them smoothly.
The jump happens because:
$$ \text{Exact} \neq \text{Approximation} $$
$$ \text{Jump} = |\text{Exact} - \text{Multipole}| \text{ at } R_{cutoff} $$

There are two ways to handle this:

**A. The Rigorous Way (High Order / High Theta):**
If you use $\theta = 2.0$ (distance is double the size) and include the Quadrupole term (Order 2), the relative error is typically $< 10^{-4}$.
In fluid dynamics, **you do not need a blending function**. The "Jump" is smaller than the discretization error of your time integrator (Runge-Kutta).
*If you see a jump, your $\theta$ is too small or you dropped a term in the expansion.*

**B. The "Engineering" Way (Switch Function):**
If you want to use a very aggressive cutoff (e.g., $\theta = 1.1$) to save performance, you *must* use a switch function $S(r)$.
Let $x = R / (r_A + r_B)$.
$$ \mathbf{u} = S(x) \cdot \mathbf{u}_{Far} + (1 - S(x)) \cdot \mathbf{u}_{Near} $$
*Do not do this.* It violates divergence-free conditions ($\nabla \cdot u \neq 0$) because the derivative of the switch function adds a non-physical source term.

**Recommendation:** Stick to Method A.
Use **Order 1 (Dipole correction)** as derived above.
Set $\theta = 1.5$ to $2.0$.
The decay is $1/R^2$. At $R=2$, error is small. At $R=10$, error is zero.
Since you sum over many clusters, the random errors tend to cancel out (Central Limit Theorem applied to truncation error).

### Summary for your "Hybrid" Solver
1.  **Data:** Particles + Clusters (Center, Radius, $\Omega$, $T$).
2.  **Split:** Use distance vs radius check ($R > 2.0 \cdot (r_A + r_B)$).
3.  **Far Kernel:** Dipole-Dipole interaction (Velocities decaying as $1/R^2$ and $1/R^3$).
4.  **Near Kernel:** Biot-Savart with regularization ($\sigma$).
5.  **Complexity:** $K^2$ for the far field, $O(N)$ for near field (assuming constant density).

This is a robust, mesh-free Lagrangian solver.