
/// @file @brief This demo implements the classic Radiosity global illumination algorithm using `Radiosity.h`. It calculates the diffuse inter-reflection of light within a scene, in this case, a labyrinth of corridors. The result is a soft, realistic lighting effect with color bleeding, where light bounces off surfaces and illuminates others. The calculation is iterative, and the user can likely watch the scene's lighting converge to the final solution.
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <vector>
#include <math.h>

#include <SDL2/SDL.h>
#include <SDL2/SDL_opengl.h>
#include "Draw3D.h"
#include "Solids.h"

#include "fastmath.h"
#include "Vec3.h"
#include "Mat3.h"
#include "quaternion.h"
#include "raytrace.h"
//#include "Body.h"

#include "geom3D.h"
#include "Radiosity.h"


#include "AppSDL2OGL_3D.h"
#include "testUtils.h"

// ============= Application

/*
Triangle3D trinagles[] = {
 (Triangle3D){ (Vec3d){0.0,0.0,0.0}, (Vec3d){1.0,0.0,0.0}, (Vec3d){0.0,1.0,0.0}  },
 (Triangle3D){ (Vec3d){0.0,0.0,0.0}, (Vec3d){1.0,0.0,0.0}, (Vec3d){0.0,0.0,1.0}  }
};

*/

const int nVerts = 32;
const int nTris  = 46;
const int nFaces = 23;


// generated by python script :   SimpleSimulationEngine/python/utils/unpack_obj.py

Vec3d verts[] = {{1.0,-1.0,-1.0},{1.0,-1.0,1.0},{-1.0,-1.0,1.0},{-1.0,-1.0,-1.0},{1.0,1.0,-0.999999},{0.999999,1.0,1.000001},{-1.0,1.0,1.0},{-1.0,1.0,-1.0},{1.0,2.479091,-0.999999},{0.999999,2.479091,1.000001},{-1.0,2.479091,-1.0},{-1.0,2.479091,1.0},{0.999999,1.0,2.701865},{-1.000001,1.0,2.701864},{0.999999,2.479091,2.701865},{-1.000001,2.479091,2.701864},{0.999998,1.0,4.40615},{-1.000002,1.0,4.406149},{0.999998,2.479091,4.40615},{-1.000002,2.479091,4.406149},{0.999999,3.407455,2.701865},{-1.000001,3.407455,2.701864},{0.999998,3.407455,4.40615},{-1.000002,3.407455,4.406149},{0.999999,4.218009,2.701865},{-1.000001,4.218009,2.701864},{0.999998,4.218009,4.40615},{-1.000002,4.218009,4.406149},{0.999999,3.407455,0.989283},{-1.0,3.407455,0.989282},{0.999999,4.218009,0.989283},{-1.0,4.218009,0.989282}};
Vec3i tris [] = {{0,1,2},{0,2,3},{1,5,6},{1,6,2},{2,6,7},{2,7,3},{4,0,3},{4,3,7},{8,10,11},{8,11,9},{7,6,11},{7,11,10},{4,7,10},{4,10,8},{15,13,17},{15,17,19},{9,11,15},{9,15,14},{6,5,12},{6,12,13},{11,6,13},{11,13,15},{17,16,18},{17,18,19},{13,12,16},{13,16,17},{21,23,27},{21,27,25},{14,15,21},{14,21,20},{15,19,23},{15,23,21},{19,18,22},{19,22,23},{24,25,27},{24,27,26},{21,25,31},{21,31,29},{23,22,26},{23,26,27},{28,29,31},{28,31,30},{20,21,29},{20,29,28},{25,24,30},{25,30,31}};

void drawObstacles( Radiosity& rad ){
    for( int i=0; i<rad.triangleObstacles.size(); i++ ){
        Triangle3D& tri = rad.triangleObstacles[i];
        Draw3D::drawTriangle( tri.a, tri.b, tri.c );
    }
}

void drawElements( Radiosity& rad ){
    for( SurfElement& el : rad.elements ){
        Draw3D::drawPointCross(el.pos, 0.01);
        Draw3D::drawVecInPos(el.normal*0.05, el.pos);
    }
}

void drawPanels( int n, SurfElement* elems,  double* vals, float sz, float sc ){
    glBegin(GL_QUADS);
    for(int i=0; i<n; i++){
        Vec3d p = elems[i].pos;
        Vec3d nr, up,fw;
        nr = elems[i].normal;
        elems[i].normal.getSomeOrtho(up,fw);
        up.mul(sz);
        fw.mul(sz);
        //printf("%i (%g,%g,%g)  (%g,%g,%g) (%g,%g,%g) (%g,%g,%g) \n", i, p.x, p.y, p.z,  nr.x, nr.y, nr.z,  fw.x, fw.y, fw.z,  up.x, up.y, up.z );
        float c = vals[i]*sc;
        glColor3f( c,c,c );
        glVertex3f( p.x+up.x, p.y+up.y, p.z+up.z );
        glVertex3f( p.x-fw.x, p.y-fw.y, p.z-fw.z );
        glVertex3f( p.x-up.x, p.y-up.y, p.z-up.z );
        glVertex3f( p.x+fw.x, p.y+fw.y, p.z+fw.z );
    }
    glEnd();
}

void drawCouplings( const Radiosity& sys, double cTrash ){
    glDisable( GL_DEPTH_TEST );
    //glBlendEquationSeparate( GL_MAX, GL_MAX );
    glEnable(GL_BLEND);
    glBlendEquation(GL_MAX);
    glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
    glBegin(GL_LINES);
    int n = sys.elements.size();
    //printf( "n %i \n", n );
    for(int i=0; i<n; i++){
        Vec3d pi = sys.elements[i].pos;
        for(int j=0; j<i; j++){
            int ij = i*n+j;
            double cij = sys.M[ij];
            //if(j==0)printf( "M[i,j] %g\n", i, j, cij );
            if( cij > cTrash ){
                Vec3d pj = sys.elements[j].pos;
                //float c = 0.1*sqrt(cij/cTrash);
                float c = 0.05*cij/cTrash;
                if(c>1)c=1;
                //if(j==0)printf( "M[i,j] %g c %g\n", i, j, cij, c );
                //glColor4f(0.0,1.0,0.0,c);
                glColor4f(0.0,c,0.0,1.0);
                //glColor4f(0.0,1.0,0.0,0.1);
                Draw3D::vertex( pi );
                Draw3D::vertex( pj );
            }
        }
    }
    glEnd();
}


class TestAppRadiosity : public AppSDL2OGL_3D { public:
    Radiosity rad;
    int ogl_complings;

	virtual void draw   ();
	virtual void drawHUD();
	//virtual void mouseHandling( );
	virtual void eventHandling   ( const SDL_Event& event  );
	//virtual void keyStateHandling( const Uint8 *keys );

	TestAppRadiosity( int& id, int WIDTH_, int HEIGHT_ );

};

TestAppRadiosity::TestAppRadiosity( int& id, int WIDTH_, int HEIGHT_ ) : AppSDL2OGL_3D( id, WIDTH_, HEIGHT_ ) {
    ogl_complings = glGenLists(1);
    glNewList( ogl_complings, GL_COMPILE);
    //rad.processTriangles( 2, trinagles, 0.05 );

    //rad.addTriangle( (Triangle3D){ (Vec3d){0.0,0.0,0.0}, (Vec3d){1.0,0.0,0.0}, (Vec3d){0.0,1.0,0.0}  },   0.1 );
    //rad.addTriangle( (Triangle3D){ (Vec3d){0.0,0.0,0.0}, (Vec3d){1.0,0.0,0.0}, (Vec3d){0.0,0.0,1.0}  },   0.1 );
    //rad.triangleObstacles.push_back( (Triangle3D){ (Vec3d){0.2,0.2,0.2}, (Vec3d){1.0,0.0,0.0}, (Vec3d){0.0,1.0,1.0}  } );

    //rad.addTriangle( (Triangle3D){ (Vec3d){0.0,0.86602540378,0.0}, (Vec3d){0.5,0.0,0.0}, (Vec3d){-0.5,0.0,0.0}  },   0.1, true  );
    //rad.addTriangle( (Triangle3D){ (Vec3d){0.0,0.0,0.86602540378}, (Vec3d){0.5,0.0,0.0}, (Vec3d){-0.5,0.0,0.0}  },   0.1, true  );
    //rad.addTriangle( (Triangle3D){ (Vec3d){0.0,0.8,0.8},           (Vec3d){0.5,0.3,0.3}, (Vec3d){-0.5,0.3,0.3}  },   0.1, false );
    //ad.triangleObstacles.push_back( (Triangle3D){ (Vec3d){0.0,0.8,0.8}, (Vec3d){0.5,0.3,0.3}, (Vec3d){-0.5,0.3,0.3}  } );

    //rad.fromMesh( Solids::Cube.ntri-2, Solids::Cube.tris, Solids::Cube.verts, 0.1, true );
    //rad.fromMesh( 4, Solids::Cube.tris, Solids::Cube.verts, 0.1, true );
    rad.fromMesh( nTris, tris, verts, 0.2, true );

    printf( " nElements %i \n", rad.elements.size() );

    rad.makeCouplingMatrix();
    rad.prepare();

    drawCouplings( rad, 0.002 );

    for( int i=0; i<rad.elements.size(); i++ ){ rad.sources[i]=0.0; rad.vals[i]=0.0; }
    for( int i=0; i<30; i++ ){ rad.sources[i]=1.0; }

    glEndList();
}

void TestAppRadiosity::draw(){
    //rintf( " ==== frame %i \n", frameCount );
    glClearColor( 0.1f, 0.1f, 0.1f, 1.0f );
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );


	glCallList( ogl_complings );

    glDisable( GL_LIGHTING   );
    //glEnable( GL_LIGHTING   );
    glEnable( GL_DEPTH_TEST );
    //glDisable( GL_DEPTH_TEST );

	//glColor3f(0.8,0.8,0.8);  drawElements( rad );
	//glColor3f(0.0,0.0,0.0);  drawObstacles(rad);
	//glColor3f(0.0,0.0,1.0); glCallList(ogl_complings);

	rad.step_Direct();

	drawPanels( rad.elements.size(), &rad.elements[0],  rad.vals, 0.1, 10.0 );
	//drawPanels( rad.elements.size(), &rad.elements[0],  rad.sources, 0.1 );

    //double t;
    //Vec3d hitpos, normal;
    //rad.step_CG();


    //glColor4f( 0.0,1.0,0.0, 0.1 );
    //Draw3D::drawLine( (Vec3f){-1.0,0.0,0.0}, (Vec3f){1.0,0.0,0.0} );

    //Draw3D::drawTriangles( nTris, (int*)tris, verts );

};


void TestAppRadiosity::eventHandling ( const SDL_Event& event  ){
    //printf( "NonInert_seats::eventHandling() \n" );
    switch( event.type ){
        case SDL_KEYDOWN :
            switch( event.key.keysym.sym ){
                case SDLK_p:  first_person = !first_person; break;
                case SDLK_o:  perspective  = !perspective; break;
                //case SDLK_r:  world.fireProjectile( warrior1 ); break;
            }
            break;
    };
    AppSDL2OGL::eventHandling( event );
}


void TestAppRadiosity::drawHUD(){
    glDisable ( GL_LIGHTING );
}

// ===================== MAIN

TestAppRadiosity * thisApp;

int main(int argc, char *argv[]){
	SDL_Init(SDL_INIT_VIDEO);
	SDL_GL_SetAttribute(SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 1);
	//SDL_SetRelativeMouseMode( SDL_TRUE );
	int junk;
	thisApp = new TestAppRadiosity( junk , 800, 600 );
	thisApp->loop( 1000000 );
	return 0;
}
