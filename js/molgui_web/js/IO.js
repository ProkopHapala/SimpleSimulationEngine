export class IO {
    constructor(system, renderer) {
        this.system = system;
        this.renderer = renderer;
    }

    // --- XYZ Parser ---
    parseXYZ(content) {
        const lines = content.split('\n');
        const atoms = [];

        // First line is number of atoms (optional in some loose parsers, but standard in XYZ)
        // Second line is comment
        // Subsequent lines: Element X Y Z

        let startLine = 0;
        // Try to find the first line with atom data if header is missing or malformed
        // But strictly XYZ has 2 header lines.

        // Let's assume standard XYZ for now
        if (lines.length > 2) {
            startLine = 2;
        }

        for (let i = startLine; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;

            const parts = line.split(/\s+/);
            if (parts.length < 4) continue;

            const elementStr = parts[0];
            const x = parseFloat(parts[1]);
            const y = parseFloat(parts[2]);
            const z = parseFloat(parts[3]);

            if (isNaN(x) || isNaN(y) || isNaN(z)) continue;

            // Map element string to atomic number (simplified)
            let type = 0;
            const el = elementStr.toUpperCase();
            if (el === 'H') type = 1;
            else if (el === 'C') type = 6;
            else if (el === 'N') type = 7;
            else if (el === 'O') type = 8;
            else if (el === 'S') type = 16;
            else if (el === 'FE') type = 26;
            // Add more as needed or use a proper table

            atoms.push({ type, x, y, z });
        }

        return atoms;
    }

    // --- XYZ Generator ---
    generateXYZ() {
        let content = `${this.system.nAtoms}\nGenerated by MolGUI\n`;

        // Reverse map for types
        const typeMap = { 1: 'H', 6: 'C', 7: 'N', 8: 'O', 16: 'S', 0: 'X' };

        for (let i = 0; i < this.system.nAtoms; i++) {
            const type = this.system.types[i];
            const el = typeMap[type] || 'X';
            const x = this.system.pos[i * 3].toFixed(6);
            const y = this.system.pos[i * 3 + 1].toFixed(6);
            const z = this.system.pos[i * 3 + 2].toFixed(6);

            content += `${el} ${x} ${y} ${z}\n`;
        }

        return content;
    }

    // --- Load File ---
    loadXYZ(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            this.loadXYZString(e.target.result);
        };
        reader.readAsText(file);
    }

    loadXYZString(content) {
        const atoms = this.parseXYZ(content);

        window.logger.info(`Parsed ${atoms.length} atoms.`);

        this.system.clear();
        for (const atom of atoms) {
            this.system.addAtom(atom.x, atom.y, atom.z, atom.type);
        }

        // Rebuild bonds using MMParams
        if (window.app && window.app.mmParams) {
            this.system.recalculateBonds(window.app.mmParams);
        } else {
            this.system.recalculateBonds(); // Fallback to default
        }

        this.renderer.update();
        window.logger.info("Scene updated.");
    }

    // --- Save File ---
    saveFile(filename = 'molecule.xyz') {
        const content = this.generateXYZ();
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();

        URL.revokeObjectURL(url);
        window.logger.info(`Saved ${filename}`);
    }
}
