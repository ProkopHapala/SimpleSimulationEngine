[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/ProkopHapala/SimpleSimulationEngine)

# Simple Simulation Engine
a minimalistic engine for: 
- Physical simulations 
- Numerical math 
- Game development 
- Computer graphics
- Educational purposes

## Table Of Contents
<!-- TOC -->

- [Simple Simulation Engine](#simple-simulation-engine)
    - [Table Of Contents](#table-of-contents)
    - [Structure and Dependecies](#structure-and-dependecies)
    - [Compilation](#compilation)
            - [quickstart](#quickstart)
            - [remarks](#remarks)
    - [Content](#content)
        - [C++ part](#c-part)
                - [C++ Planned or Preliminary or ToDo](#c-planned-or-preliminary-or-todo)
        - [Python](#python)
        - [Web](#web)
    - [Aim and Philosophy](#aim-and-philosophy)

<!-- /TOC -->

## Structure and Dependecies 
* [Computational core](cpp/common) is written in C/C++11. It should have no dependencies on external libraries. Even C++STL is avoided where possible. Attempt is made to optimize simultanously run-time speed, code length, compilation time, and interal interdependece of modules. In that respect especially tradeoffs for using templates and class hierarchies are considered.
* C/C++ part is compiled using CMake 2.8 and tested with gcc 5.4.0 on Ubunt 16.04. Code::Blocks project is generated by `cmake .. -G "CodeBlocks - Unix Makefiles"`. There are [several CMake projects](cpp/Builds) for different parts which differ in dependencies
* Standalone [apps, games](cpp/apps) and [demos](cpp/sketches_SDL) use SDL2 and OpenGL 1.2 and 4.0 for Graphical user interface. Some other dependencies (e.g. SDL2-net, SDL2-image, SDL2-ttf) may be added to particular build target but are not required globaly.
* There is stand allone set [GPU accelerated simulations](cpp/sketches_OCL) using OpenCL
* Some apps use embeded Lua3.2 for scripting, but it is not globally required.
* Python 2.7 + numpy + matplotlib is used to make [convenient science/engineering packeges](python) partialy wrappaing the C/C++ core libraries. 
* In addition there are some [documents](projects) using iPython (Jupyter) and [javascript+WebGL](js) for rendering interactive 3D graphics and editors of glsl shaders on web. These are independent on the rest.

## Compilation 
 * tested on Ubunu 16.04 64bit)
#### quickstart
1. make sure you have installed `gcc >=5.4.0`, `CMake >2.8`, `libglew-dev`, `SDL2-dev`
2. got to `cpp/Builds/sketches_SDL/` create subdirectory `Build`
1. from `cpp/Builds/sketches_SDL/Build` generate makefiles by `cmake .. -G "CodeBlocks - Unix Makefiles"`
2. in the same directory compile the project `make`. The compiled binaris are stored in `cpp/Build`

#### remarks
  * you may also load Code::Blocks project `cpp/Builds/sketches_SDL/SimpleSimulationEngine.cbp` and compile particular build target from Code::Blocks
  * If `cmake` or `make` fails due to some dependencies, you may try compile just part of the project (e.g. `cpp/Build/libs`) which has less dependencies 
  * you may also remove problematic build targets by commenting out particular parts of `CMakeFile.txt`
 
 #### optional
 6. If you were able to compile `sketches_SDL` you may try compile applications and games in `cpp/Builds/apps/` or the whole project in the same way just in `cpp/Builds/all/` (you will need `liblua5.2-dev` and `libtolua5.2-dev`) 
 7. You may try compile OpenCL demos in `cpp/Build/sketches_OCL` in the same way. This will require properly installed GPU drivers and opencl libraris. These are platform dependent. Personally I tested with `nvidia-opencl-dev`.
    * **Note:** be very carefull when installing GPU drivers on linux, ou can easily brak the system (I did 3 times). In my case `nvidia-opencl-dev` installed dependecies `libcuda-378 nvidia-378 nvidia-opencl-icd-378 nvidia-prime nvidia-settings opencl-headers`. I also added `nvidia-modprobe`. When you break your system this make help:
      ```
      sudo apt-get autoremove --purge nvidia-*
      sudo stop lightdm
      sudo apt-get install xserver-xorg-video-nouveau
      ```
      there are many guides for installing GPU drivers on linux. I found particularily helpfull and working [this one](https://askubuntu.com/questions/335285/how-to-change-proprietary-video-driver-using-the-command-line)

## Content
<font color="green"> This is work in progress. Often particular modules of the engine are functional, but they are not put together to build an unified system and work together. </font>

### C++ part
- [Math](cpp/common/math)
  - [2d vector](cpp/common/math/Vec2.h), [3d vector](cpp/common/math/Vec3.h), [3x3 matrix](cpp/common/math/Mat3.h), [4x4 matrix](cpp/common/math/Mat4.h), [Quaternions](cpp/common/math/Mat3.h)
  - [Fast math rutines](cpp/common/math/fastmath.h) with approximations of some functions ( e.g. [goniometry](cpp/common/math/gonioApprox.h), Error function ... )
  - Functions with derivatives ( like [tresholds and sigmoides](cpp/common/math/fastmath.h), and Lorenzieans [etc.](cpp/common/math/functions.h) )
  - [Composing](cpp/common/math/warpFunction2D.h) of complicated 1D,2D,3D functions from simple primitives with analytic gradients 
  - Splines in 1D, 2D 3D, e.g. cubic [hermite spline](cpp/common/math/spline_hermite.h) <font color="green" size=2> (other splines needs to be systematized) </font>
  - [Simplex noise] (cpp/common/math/Noise.h)
  - Basic [linear algebra](cpp/common/math/Lingebra.h) ( matrix multiplication, transpose, GaussJordan solver, Biconjugate gradinet iterative solver, Fitting, Jacobi matrix diagonalization), and [N-dimensional vectors](cpp/common/math/VecN.h) 
  - Minimalistic [Fourier transform](cpp/common/math), with FFT for $2^N$ elemetns
- Math solvers
  - [Brent line search](cpp/common/optimization/lineSearch.h)
  - [Stochastic optimization](cpp/common/optimization/optimizer_random.h)  
  - iterative non-linear [gradient based optimization](cpp/common/math/DynamicOpt.cpp) using [FIRE](http://users.jyu.fi/~pekkosk/resources/pdf/FIRE.pdf) (faster and more robust CG, comparable and sometimes better than BFGS) 
  - Variable step [ODE integrator](cpp/common/dynamics/ODEintegrator.h) by [Runge–Kutta–Fehlberg](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method)
- Computational Geometry  
  - Basic [2d](cpp/common/math/geom2D.h) and [3d](cpp/common/math/geom3D.h) shapes [computational geometry](), [ray tracing](cpp/common/math/raytrace.h), [Covex polygons](cpp/common/math/Convex2d.h), [polygon Mesh](cpp/common/math/Mesh.h) and [regular polyhedra](cpp/common/math/Solids.h)
- [Spatial datastructures](cpp/common/maps) - <font color="green" size=2> This needs cleanup, there is too many duplicite methods/versions. Especially, Rulers should be splited from data. </font>
  - Various methos for acceleration of local interactions and nearest neighbor search e.g. [HashMap](cpp/common/dataStructures/HashMat.h), nD BoundigSphere hierarchy, and grids.
  - Various grids ([trinagular](cpp/common/dataStructures/SimplexGrid.h), [rectangular](cpp/common/dataStructures/Ruler2DFast.h), [cubic](cpp/common/maps/CubicRuler.h), and [triclinc](cpp/common/dataStructures/Grid.h) )
  - Some maps suport raymarching/rasterization e.g. [trinagular](cpp/common/dataStructures/SimplexGrid.h) and [cubic](cpp/common/maps/CubicRuler.h)
- Physical simulations
  - Rigid-Body dynamics in [2D](cpp/common/dynamics/Body2D.h) and [3D](cpp/common/dynamics/Body.h) - with application in [RigidBody molecular dynamics](cpp/common/dynamics/MolecularWorld.h), [Flight dynamics](cpp/common/dynamics/AeroCraft.h) and [vehicle on tarrain](/cpp/apps/Tanks), and [Sailing](cpp/apps/SailWar)
  - [SoftBody](cpp/common/dynamics/SoftBody.h) dynamics with [Truss simulation](cpp/apps/BlockHouseTactics) (e.g. for something like BridgeBuilder)
  - [Molecular mechanics](cpp/common/dynamics/MMFF.h) used [there](cpp/apps/MolecularEditor2)
  - simulation of [hydraulic errosion](cpp/common/maps/TerrainHydraulics.h) for [terrain generation](cpp/sketches_SDL/2D/test_TerrainHydraulics.cpp)
- GUI and interfaces
  - basic SDL2 application prefabricates in [2D](cpp/common_SDL/SDL2OGL/AppSDL2OGL.h) and [3D](cpp/common_SDL/SDL2OGL/AppSDL2OGL_3D.cpp)
  - Basic lightweight [GUI](cpp/common_SDL/SDL2OGL/GUI.h) components (buttons, sliders, input box ... ) for SDL2
  - basic [plotting](cpp/common_SDL/SDL2OGL/Plot2D.h) utilities for 1D,2D and 3D data (inspired by matplolib)
- Graphics
  - OpenGL 1.2/2
    - drawing many basic primitives and more complex shapes in [2D](cpp/common_SDL/SDL2OGL/Draw2D.h) and [3D](cpp/common_SDL/SDL2OGL/Draw3D.h)
  - OpenGL 3+
    - Examples of Rendering [meshes](cpp/sketches_SDL/test_MeshOGL3.cpp), [rendering to texture](test_RenderToTexture.cpp), [instances](cpp/sketches_SDL/test_Instances.cpp), [bilboards](cpp/sketches_SDL/cpp/sketches_SDL/test_Sprites.cpp)
    - [ScreenSpace ambient occlusion](cpp/sketches_SDL/OGL3/test_SSAO.cpp)
    - Ray-Traced analytic primitives e.g. Spherical [atoms](cpp/sketches_SDL/test_Atoms.cpp)
    - Ray-Marching of analytical functions e.g. [molecular orbitals](cpp/sketches_SDL/test_OrbitalRayMarch.cpp).
    - <font color="green" size=2>TODO: (in-shader Constructive solid geometry CGS)</font>
    - [Terrain rendering](cpp/sketches_SDL/test_LandScape.cpp) from heightmap texture with logaritmic depth buffer for large scenes
    - Angularly sensitive bilboards (impostors) for rendering [Vegetation](cpp/sketches_SDL/test_Vegetation.cpp) and clouds

- Apps and Games
  - Molecular editors with [Rigid Body Molecular dynamics](cpp/apps/MolecularEditor) (coarse grained=>faster, no need for intramoleculer forcefiel) with [python interface](python/pyMolecular), and normal [Soft Body Molecular mechanics](cpp/apps/MolecularEditor2)
  - 3D subsonic [aircraft combat simulator](cpp/apps/AeroCombat)
  - 2D [Sail-ships simulator](cpp/apps/SailWar) with [multiplayer](cpp/apps/SailWar_Multi) and [battleship simulator]() 
  - [Land-Combat tactical simulator](cpp/apps/LandTactics) simulator for WWII and modern era 
  - 3D [Tank simulator](cpp/apps/Tanks) 
  - 2D [historical battle simulator](cpp/apps/FormationTactics) (TotalWar like) with large army (~30000 soldiers)
  - Realistic [Spaceship desing and simulation](cpp/apps/OrbitalWar) game 
  
##### C++ Planned or Preliminary or ToDo
  - multipole expansion
  - fast multipole method or FFT for long range interactions
  - Global optimization algorithms for molecular simulation
  - easy to use generic rendering and physical engine for games (with scene graph) which goes together seamlessly 

### Python
 * [pyMolecular](python/pyMolecular) - Rigid Body Molecular dynamics ([test](test_Molecular.py))
 * [pyRay](python/pyRay) - real-time Constructive Solid Geometry by ray-marching on GPU using pyOpenCL
 * [pySimE](python/pySimE) - Physics and chemistry suite with many useful functions
    * Pure python
      * [enumeration of chemical reactions](test_chem_fuels2table.py) and calculation of [entalpy bilance](test_chem_entalpy.py)
      * Comparison of performance for various [spacecraft propulsion](test_KosmoSuite_shipAccel.py)
    * Using C++ libraries
      * [Trajectory of electron](test_KosmoSuite_elmag.py) in electromagnetic field generated by arbitrary shape of coil 
      * phenomenological calculation of [nuclar bomb yield](test_KosmoSuite_FissionPulse.py) by time propagation of rate equations in 0D.
      * N-body simulations of [planet orbits](test_KosmoSuite_nbody.py) using [RKF45](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method)
      * Simulation of [Rocket launch](test_KosmoSuite_SpaceLaunchODE.py) from plant surface (considering also aerodynamic drag)
  * [pyShock](python/pyShock) time propagation shockwaves in 1D (planar, cylinrical or spherical symmetry) - e.g. for implosion of nuclear bombs (WIP)

### Web
projects using HTML + Javascritp + WebGL + THREE.js and/or Python Jupyter.nb

* [SpaceCombat](projects/SpaceCombat/readme.md) - ideas about combat in solar system supported by physical calculations in python (Jupyter.nb) ([see example](https://nbviewer.jupyter.org/github/ProkopHapala/SimpleSimulationEngine/blob/master/projects/SpaceCombat/ch1_basics.ipynb) and [3D graphics](https://rawgit.com/ProkopHapala/SimpleSimulationEngine/master/projects/SpaceCombat/HTML/StickSpaceCraft.html) (WebGL+Three.js) - it is strongly inspired by [Project Rho: Atomic rockets ](http://www.projectrho.com/public_html/rocket/)

* Web interfaces for building fragment shaders inspired by [ShaderToy](https://www.shadertoy.com/)
  * [RayTraced analytical primitives](js/GLSL_solid_modeling/ListOfPrimitives.html) for other shaders 
  * [PlanetDesigner](js/PlanetDesigner) - web interface for building glsl fragment shaders for procedural generation and rendering of planets seen from space
  * [ShaderDebug](js/PlanetDesigner) - debuging [domain wraping functions](http://iquilezles.org/www/articles/warp/warp.htm) used for procudural generation of other shaders 

## Aim and Philosophy
Main motivation is to assemble various common algorithma from physics, numerical mathematics, computer graphics and computer science and build minimalistic tools for rapid development of physical simulation programs and games. 

**It should be:**
- **Didactic** - user is expected to be able to understand how things works inside ( i.e. it should not be a blackbox ). The code sould document intself (without much comment strings or external doc).
- Focused on development of **small programs** ( like sketches/demos ) 
- Each particular part of the engine should be **illustrated** by simplistic example / demo
- **Minimal dependencies** on 3rd party libraries.
- **Minimalized inter-dependencies** between different modules within the engine. Many modules are designed to work independently, and be easily plugged into other projects 
  * often just as header files (`.h`)
- **No compicated instalation** procedures required
- It is rather a **set of tools** and pre-programed **code samples** rather than enclosed package
- It does not follow rigorous Object Oriented Programing paradigma and other good practices of software enginering common in large projects. Especially [*encapsulation*](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)) resp. [*information hiding*](https://en.wikipedia.org/wiki/Information_hiding) **is avoided** (everything is `public`), since otherwise it would lead to huge boiler-plate code (`.get()` and `.set()`) and limited or tedious user extensions.
- **User is expected and ecouraged to modify the code** (including core parts) to match requirements of his particular project. It should be more a starting point of further development rather than final product.
- C++11 is used in pragmatic way, not *ideologically*. 
  - E.g. pass by reference, `templates` and `lambda` expressions are used for programming convenience and computational performance. 
  - At the same time old-schoop C is often prefered: 
    - `printf` is used instead of `std:iostrem` 
    - `char*` instead of `string` 
    - raw pointers `double*` for arrays instead of `std:vector` or [smart pointers](https://msdn.microsoft.com/en-us/library/hh279674.aspx)  
